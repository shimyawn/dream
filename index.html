<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dream Factory: Puck's Night (Final Fix)</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f8ff; transition: background-color 4s; font-family: 'Courier New', monospace; }
        canvas { display: block; }

        /* UI Layers */
        #left-ui {
            position: absolute; top: 20px; left: 20px;
            font-family: 'Press Start 2P', cursive;
            z-index: 10; pointer-events: none;
            text-shadow: 2px 2px 0px #000;
            max-width: 450px;
        }
        #factory-title {
            font-size: 22px; margin: 0 0 15px 0; line-height: 1.4;
            transition: color 2s;
        }
        .title-day { color: hotpink; }
        .title-night { color: #ffffcc; }
        #factory-desc {
            font-size: 14px; color: #636363; line-height: 1.6; 
            font-family: 'Noto Sans KR', sans-serif; font-weight: bold;
            transition: color 2s; text-shadow: none;
        }
        #night-disclaimer { display: none; color: #2ecc71; margin-top: 10px; font-size: 0.9em; }

        #time-bar-container {
            position: absolute; top: 30px; right: 250px;
            width: 150px; height: 10px;
            background: rgba(0,0,0,0.3); border-radius: 5px;
            z-index: 10; pointer-events: none;
        }
        #time-marker {
            position: absolute; top: -10px; left: 0%;
            font-size: 24px; margin-left: -12px; transition: left 0.1s linear;
        }

        #puck-msg-box {
            position: absolute; display: none; padding: 10px 15px;
            background-color: #000; border: 2px solid #00ff00; color: #00ff00;
            font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px;
            box-shadow: 5px 5px 0px rgba(0,0,0,0.5); z-index: 100; max-width: 300px; pointer-events: none;
        }
        .blink-cursor { animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #ending-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive;
            z-index: 999; text-align: center; pointer-events: none;
        }
        .end-nightmare { background: rgba(0, 20, 0, 0.95); color: #00ff00; }
        .end-sweet { background: rgba(255, 192, 203, 0.95); color: #ff1493; }
        .end-neutral { background: rgba(0, 0, 0, 0.9); color: #fff; }
        #end-title { font-size: 40px; margin-bottom: 20px; text-shadow: 4px 4px 0 #000; }
        #end-desc { font-size: 16px; line-height: 1.6; text-shadow: 2px 2px 0 #000; }

        /* --- Tutorial Styles --- */
        #help-btn {
            position: absolute; top: 20px; right: 20px;
            width: 36px; height: 36px; border-radius: 50%;
            background: #fff; border: 2px solid #000; font-family: 'Press Start 2P', cursive;
            font-size: 16px; cursor: pointer; z-index: 50;
            box-shadow: 2px 2px 0 #000; transition: transform 0.1s;
            display: flex; align-items: center; justify-content: center;
        }
        #help-btn:active { transform: translate(2px, 2px); box-shadow: none; }

        #tutorial-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); z-index: 200; display: flex;
            justify-content: center; align-items: flex-end; padding-bottom: 80px;
            pointer-events: auto;
        }
        #tutorial-box {
            background: rgba(15, 15, 20, 0.95); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #fff;
            padding: 20px 25px; 
            width: auto; max-width: 420px; min-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center; position: relative;
            backdrop-filter: blur(5px);
            margin: 0 20px;
        }
        #tut-title { 
            margin-top: 0; color: #f1c40f; 
            font-family: 'Press Start 2P'; font-size: 13px;
            margin-bottom: 12px; 
            letter-spacing: -0.5px;
            text-transform: uppercase;
        }
        #tut-text { 
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 14px; 
            line-height: 1.5; 
            color: #eee;
            margin-bottom: 20px; 
            min-height: 42px; 
            font-weight: 400;
            word-break: keep-all;
        }
        .tut-btn {
            background: rgba(255,255,255,0.1); 
            color: #fff; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 6px 14px; 
            font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700;
            cursor: pointer; margin: 0 4px; transition: all 0.2s;
        }
        .tut-btn:hover { background: rgba(255,255,255,0.2); }
        .tut-btn.primary { 
            background: #f1c40f; color: #111; border-color: #f1c40f; 
            box-shadow: 0 2px 10px rgba(241, 196, 15, 0.3);
        }
        .tut-btn.primary:hover { background: #f39c12; border-color: #f39c12; }
        
        #tut-highlight {
            position: absolute; border: 3px solid #f1c40f;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5), inset 0 0 10px rgba(241, 196, 15, 0.2);
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: none; z-index: 199; display: none;
        }
        .tut-hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="left-ui">
        <h1 id="factory-title" class="title-day">A Midsummer Night's Dream Factory</h1>
        <div id="factory-desc">
            VIP customer, hello. We are a premium dream factory.
            <div id="night-disclaimer">
                *WARNiNG: Puck intrusion detected.<br>
                *Oberon & Titania are defending.
            </div>
        </div>
    </div>
    <div id="time-bar-container"><div id="time-marker">ðŸŒž</div></div>
    <div id="puck-msg-box"><span id="puck-text"></span><span class="blink-cursor">_</span></div>
    
    <button id="help-btn">?</button>

    <!-- Tutorial Layer -->
    <div id="tutorial-overlay">
        <div id="tut-highlight"></div>
        <div id="tutorial-box">
            <h2 id="tut-title">Welcome!</h2>
            <p id="tut-text">Tutorial text goes here.</p>
            <div>
                <button id="tut-skip" class="tut-btn">Skip</button>
                <button id="tut-next" class="tut-btn primary">Next</button>
            </div>
        </div>
    </div>

    <div id="ending-overlay"><h1 id="end-title"></h1><p id="end-desc"></p></div>
    <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const titleElem = document.getElementById('factory-title');
const nightDisclaimer = document.getElementById('night-disclaimer');
const timeMarker = document.getElementById('time-marker');
const puckBox = document.getElementById('puck-msg-box');
const puckText = document.getElementById('puck-text');
const endingOverlay = document.getElementById('ending-overlay');
const endTitle = document.getElementById('end-title');
const endDesc = document.getElementById('end-desc');

// Tutorial Elements
const tutOverlay = document.getElementById('tutorial-overlay');
const tutTitle = document.getElementById('tut-title');
const tutText = document.getElementById('tut-text');
const tutNext = document.getElementById('tut-next');
const tutSkip = document.getElementById('tut-skip');
const tutHighlight = document.getElementById('tut-highlight');
const helpBtn = document.getElementById('help-btn');

// --- Optimization Utils ---
const rand = (min, max) => Math.random() * (max - min) + min;
const distSq = (x1, y1, x2, y2) => (x2-x1)**2 + (y2-y1)**2; 
const dist = (x1, y1, x2, y2) => Math.sqrt(distSq(x1, y1, x2, y2));

// --- Config ---
const CONFIG = {
    dayLength: 2000, 
    charSize: 16,
    speed: { walk: 1.2, run: 2.2, belt: 0.8, autoMove: 3.0, fly: 5.0 }, 
    roles: {
        mover: 5, janitor: 1, 
        worker: 8, monitorSup: 1, 
        decorator: 8, deliverer: 6, 
        office: 6, ceo: 2, puckHuman: 1 
    },
    colors: {
        memories: ['#ff9ff3', '#feca57', '#ff6b6b', '#48dbfb', '#1dd1a1', '#5f27cd'], 
        roof: ['#e74c3c', '#8e44ad', '#2980b9'],
        nightmare: '#00ff00', sweetDream: '#ff79cd',      
        belt: '#95a5a6', funnels: '#e17055',
        decoTable: '#95a5a6',
        dayBG: '#f0f8ff', nightBG: '#0f0c29'
    },
    zones: {},
    shelfCapacity: 35 
};

// --- Puck's Messages ---
const puckMessages = [
    "Puck's msg: Click on dreams so soft and fair,\nturn them to a green nightmare.",
    "Puck's msg: ðŸ˜› (Bleh!)",
    "Puck's msg: Is it not a joy to see?\nRuining dreams with wicked glee?",
    "Puck's msg: For happy dreams, if that is your will,\nclick once more, your wish fulfill.",
    "Puck's msg: I am Puck, the system's bug.\nGiving logic a mischievous tug."
];

// --- State ---
let state = {
    frame: 0, isDay: true, dayTimer: 0, phase: 'PLAYING',
    stats: { nightmare: 0, sweet: 0, neutral: 0 }, dominance: 'NEUTRAL',
    items: [], chars: [], houses: [], particles: [], pedestrians: [], dusts: [], stars: [], pucks: [], 
    shelfSlots: new Array(CONFIG.shelfCapacity).fill(null),
    monitor: { activeItem: null, timer: 0 }
};

// ==========================================
// 0. Tutorial Logic (ENGLISH)
// ==========================================

const tutorialSteps = [
    {
        title: "Welcome to Dream Factory!",
        text: "We collect precious memories and craft them into wonderful dreams. The fairies are working hard for you.",
        zone: null
    },
    {
        title: "1. Gathering (Raw Zone)",
        text: "Memory fragments from pedestrians are collected here. The orange Movers carry them to the factory.",
        zone: 'raw'
    },
    {
        title: "2. Processing (Belt)",
        text: "Fragments move along the conveyor belt. Pink Workers hammer them into shapes like stars or circles.",
        zone: 'belt'
    },
    {
        title: "3. Decoration (Deco Table)",
        text: "Shaped dreams are polished here by purple Decorators to make them shine beautifully.",
        zone: 'decoTable'
    },
    {
        title: "4. Quality Control (Monitor)",
        text: "Finished dreams are inspected here. We ensure no nightmares slip through before storage.",
        zone: 'monitor'
    },
    {
        title: "5. Delivery (Finish Zone)",
        text: "Dreams stored on shelves are picked up by yellow Deliverers and sent to the houses below.",
        zone: 'finish'
    },
    {
        title: "âš ï¸ Night Threat (Puck)",
        text: "At night, the mischievous fairy 'Puck' (who wanders in green by day) reveals his true form! He creates nightmares.",
        zone: null
    },
    {
        title: "ðŸ‘‰ Your Role (Interaction)",
        text: "Click a green Nightmare to purify it! Click the flying Puck to stun him for 3 seconds!",
        zone: null
    }
];

let currentTutStep = 0;

function startTutorial() {
    currentTutStep = 0;
    tutOverlay.classList.remove('tut-hidden');
    tutOverlay.style.display = 'flex';
    updateTutorialUI();
}

function endTutorial() {
    tutOverlay.style.display = 'none';
    tutHighlight.style.display = 'none';
}

function updateTutorialUI() {
    const step = tutorialSteps[currentTutStep];
    tutTitle.innerText = step.title;
    tutText.innerText = step.text;
    
    // Highlight Logic
    if (step.zone && CONFIG.zones[step.zone]) {
        const z = CONFIG.zones[step.zone];
        tutHighlight.style.display = 'block';
        tutHighlight.style.left = z.x + 'px';
        tutHighlight.style.top = z.y + 'px';
        tutHighlight.style.width = z.w + 'px';
        tutHighlight.style.height = z.h + 'px';
    } else {
        tutHighlight.style.display = 'none';
    }

    if (currentTutStep === tutorialSteps.length - 1) {
        tutNext.innerText = "Start!";
    } else {
        tutNext.innerText = "Next";
    }
}

tutNext.addEventListener('click', () => {
    currentTutStep++;
    if (currentTutStep >= tutorialSteps.length) {
        endTutorial();
    } else {
        updateTutorialUI();
    }
});

tutSkip.addEventListener('click', endTutorial);
helpBtn.addEventListener('click', startTutorial);


// ==========================================
// 1. Entities
// ==========================================

class Puck { // The Night Flying Puck
    constructor() {
        this.x = canvas.width/2; this.y = -50;
        this.vx = rand(-3,3); this.vy = rand(2,4);
        this.stunTimer = 0;
    }
    update() {
        if(this.stunTimer > 0) { this.stunTimer--; return; } // Stop moving if stunned
        
        this.x += this.vx; this.y += this.vy;
        
        // Bounce
        if(this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if(this.y < 0 || this.y > canvas.height - 100) this.vy *= -1;
        
        // Erratic movement
        if(Math.random() < 0.05) { this.vx = rand(-4,4); this.vy = rand(-4,4); }
        
        // Corrupt items (Green Aura Effect)
        // Puck affects ALL items/ingredients it touches
        const auraRadiusSq = 80 * 80; // Range for the "light"
        for(let item of state.items) {
            if(item.qualityType !== 1 && distSq(this.x, this.y, item.x, item.y) < auraRadiusSq) {
                item.qualityType = 1; // Turn to Nightmare
                createParticle(item.x, item.y, '#00ff00', 3);
            }
        }
    }
    hit() {
        this.stunTimer = 180; // 3 seconds at 60fps
        createEmote(this.x, this.y-20, 'ðŸ’«'); 
        createParticle(this.x, this.y, '#ffff00', 10);
    }
    draw() {
        ctx.save(); ctx.translate(this.x | 0, this.y | 0);
        
        // Green Glow Aura (Fixed: Use simple circles instead of gradients for reliable visibility and perf)
        if (this.stunTimer === 0) {
            let pulse = Math.sin(state.frame * 0.2) * 5;
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.beginPath(); ctx.arc(0, 0, 50 + pulse, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
            ctx.beginPath(); ctx.arc(0, 0, 30 + pulse/2, 0, Math.PI*2); ctx.fill();
        } else {
            // Stun effect rotation
            ctx.rotate(rand(-0.2, 0.2));
        }

        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#00ff00'; ctx.font = "12px serif"; ctx.fillText("ðŸ˜ˆ", -6, 4);
        
        // Wings
        let wingY = this.stunTimer > 0 ? 0 : Math.sin(state.frame * 0.8) * 5;
        ctx.fillStyle = 'rgba(50,255,50,0.5)';
        ctx.beginPath(); ctx.ellipse(-10, -5 + wingY, 10, 5, -0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(10, -5 + wingY, 10, 5, 0.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

class Item {
    constructor() {
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = 0; this.y = 0;
        this.baseColor = CONFIG.colors.memories[Math.floor(rand(0, CONFIG.colors.memories.length))];
        this.ingredients = [this.baseColor]; 
        this.color = this.baseColor;
        this.stage = 'RAW'; 
        this.carrier = null;
        this.reserved = false; 
        this.size = 5; 
        this.shape = 'blob'; 
        this.qualityType = 0; 
        this.processedBy = new Set();
        this.slotIndex = -1;
        this.isChunk = false; 
    }
    initChunk(ingredients) {
        this.isChunk = true; this.ingredients = ingredients;
        this.size = 6 + Math.sqrt(ingredients.length) * 2; 
        this.shape = 'blob'; this.color = ingredients[0]; 
    }
    toggleQuality() {
        // Logic: 0 -> 2 (Sweet) -> 1 (Nightmare) -> 0
        if (this.qualityType === 0) { 
            this.qualityType = 2; // Make Sweet
            createEmote(this.x, this.y-20, 'â¤ï¸'); 
        }
        else if (this.qualityType === 2) { 
            this.qualityType = 1; // Make Nightmare
            createEmote(this.x, this.y-20, '!!'); 
        }
        else { 
            this.qualityType = 0; // Back to Neutral
        }
    }
    update() {
        if (this.carrier) { 
            this.x = this.carrier.x; 
            this.y = this.carrier.type === 'deliverer' ? this.carrier.y + 15 : this.carrier.y - 14;
            return; 
        }
        if (this.y > canvas.height + 100) { this.stage = 'DELETED'; }
        
        // --- Stage Transition Logic ---
        if (this.stage === 'FLYING_TO_FACTORY') {
            let dSq = distSq(this.x, this.y, this.targetRawX, this.targetRawY);
            if (dSq < 25) { this.stage = 'RAW'; this.x = this.targetRawX; this.y = this.targetRawY; } 
            else { this.x += (this.targetRawX - this.x) * 0.05; this.y += (this.targetRawY - this.y) * 0.05; }
        }
        else if (this.stage === 'ON_BELT') {
            this.x += CONFIG.speed.belt; this.y = CONFIG.zones.belt.y + 15;
            if (this.x > CONFIG.zones.belt.x + CONFIG.zones.belt.w) {
                this.stage = 'PENDING_DECO'; 
                this.x = CONFIG.zones.beltEnd.x + rand(0, 30); this.y = CONFIG.zones.beltEnd.y + rand(0, 30);
                this.shape = 'polished'; 
            }
        }
        else if (this.stage === 'WAITING_MONITOR') {
            if (!state.monitor.activeItem) { this.stage = 'MONITORING'; } 
            else { let qx = CONFIG.zones.monitorQueue.x + CONFIG.zones.monitorQueue.w - 15; if (this.x < qx) this.x += 0.5; }
        }
        else if (this.stage === 'MONITORING') {
            state.monitor.timer++; state.monitor.activeItem = this; 
            let targetX = CONFIG.zones.monitorPad.x + CONFIG.zones.monitorPad.w/2;
            let targetY = CONFIG.zones.monitorPad.y + CONFIG.zones.monitorPad.h/2;
            this.x += (targetX - this.x) * 0.2; this.y += (targetY - this.y) * 0.2;
            if (state.monitor.timer > 30) { 
                let emptySlot = state.shelfSlots.findIndex(id => id === null);
                if (emptySlot !== -1) {
                    state.shelfSlots[emptySlot] = this.id; this.slotIndex = emptySlot;
                    this.stage = 'AUTO_MOVE_TO_SHELF';
                    state.monitor.timer = 0; state.monitor.activeItem = null;
                }
            }
        }
        else if (this.stage === 'AUTO_MOVE_TO_SHELF') {
            let row = (this.slotIndex / 5) | 0; let col = this.slotIndex % 5;
            let targetX = CONFIG.zones.finish.x + 15 + col * 22;
            let targetY = CONFIG.zones.finish.y + 15 + row * 28 + 15;
            let dSq = distSq(this.x, this.y, targetX, targetY);
            let threshold = (CONFIG.speed.autoMove + 1)**2;
            if (dSq < threshold) { 
                this.stage = 'ON_SHELF'; this.x = targetX; this.y = targetY; this.reserved = false; 
            }
            else { 
                let d = Math.sqrt(dSq);
                this.x += (targetX - this.x)/d * CONFIG.speed.autoMove; 
                this.y += (targetY - this.y)/d * CONFIG.speed.autoMove; 
            }
        }
        else if (this.stage === 'ON_SHELF') {
            if (this.slotIndex !== -1) {
                let row = (this.slotIndex / 5) | 0; let col = this.slotIndex % 5;
                this.x = CONFIG.zones.finish.x + 15 + col * 22;
                this.y = CONFIG.zones.finish.y + 15 + row * 28 + 15;
            }
        }
    }
    draw() {
        ctx.save(); ctx.translate(this.x | 0, this.y | 0);
        
        // Blink/Glow Effect (Optimized)
        if (this.qualityType === 1) { 
            // Nightmare (Green)
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; 
            ctx.beginPath(); ctx.arc(0,0, this.size+6, 0, Math.PI*2); ctx.fill();
        }
        else if (this.qualityType === 2) { 
            // Sweet (Pink)
            ctx.fillStyle = 'rgba(255, 105, 180, 0.4)'; 
            ctx.beginPath(); ctx.arc(0,0, this.size+6, 0, Math.PI*2); ctx.fill();
        }

        if (['PACKED', 'WAITING_MONITOR', 'MONITORING', 'AUTO_MOVE_TO_SHELF', 'ON_SHELF', 'DELIVERING'].includes(this.stage) || (this.carrier && this.stage === 'PACKED')) {
            ctx.fillStyle = this.ingredients[0]; ctx.fillRect(-6, -6, 12, 12);
            ctx.fillStyle = '#fff'; ctx.fillRect(-2, -6, 4, 12); ctx.fillRect(-6, -2, 12, 4);
            ctx.strokeStyle = '#fff'; ctx.lineWidth=1; ctx.strokeRect(-6,-6,12,12);
            ctx.restore(); return;
        }
        if (this.stage === 'DELETED') { ctx.restore(); return; }
        if (this.isChunk) {
            let radius = this.size * (this.carrier ? 0.8 : 1);
            ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); 
            if(this.ingredients.length > 1) {
                let grad = ctx.createLinearGradient(-radius, -radius, radius, radius);
                this.ingredients.forEach((c, i) => grad.addColorStop(i/(this.ingredients.length-1), c));
                ctx.fillStyle = grad;
            } else { ctx.fillStyle = this.ingredients[0]; }
            ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.4)'; for(let i=0; i<3; i++) ctx.fillRect(rand(-3,3), rand(-3,3), 2, 2);
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill();
        }
        ctx.restore();
    }
}

// ==========================================
// 2. Characters & Subclasses
// ==========================================

class Character {
    constructor(type, id) {
        this.type = type; this.id = id;
        this.x = 0; this.y = 0;
        this.target = null; this.state = 'IDLE'; 
        this.timer = 0; this.jumpY = 0; this.jumpV = 0;
        this.backpack = []; 
        this.initPos();
    }

    initPos() {
        if(this.type === 'worker') { this.x = CONFIG.zones.belt.x + CONFIG.charSize*2 + this.id * 50; this.y = CONFIG.zones.belt.y + 45; }
        else if (this.type === 'monitorSup') { this.x = CONFIG.zones.monitor.x + 120; this.y = CONFIG.zones.monitor.y + 80; }
        else if (this.type === 'office') { this.x = CONFIG.zones.office.x + 30 + (this.id%3)*60; this.y = CONFIG.zones.office.y + 40 + Math.floor(this.id/3)*50; }
        else { this.x = CONFIG.zones.raw.x; this.y = CONFIG.zones.raw.y; }
    }

    reset() { this.target = null; this.state = 'IDLE'; this.timer = 0; this.backpack = []; this.jumpY=0; this.jumpV=0; }
    jump() { if(this.jumpY === 0) this.jumpV = -6; }
    
    // Optimized moveTo
    moveTo(tx, ty, spd, onComplete) {
        let dSq = distSq(this.x, this.y, tx, ty);
        if(dSq < 25) { if(onComplete) onComplete(); } 
        else { 
            let d = Math.sqrt(dSq);
            this.x += (tx - this.x)/d * spd; this.y += (ty - this.y)/d * spd; 
        }
    }
    
    update(speedMult) {
        if (this.jumpV !== 0 || this.jumpY !== 0) {
            this.jumpY += this.jumpV; this.jumpV += 0.5; if(this.jumpY >= 0) { this.jumpY = 0; this.jumpV = 0; }
        }
        
        if (!state.isDay) {
            if (state.dominance === 'NIGHTMARE' && Math.random()<0.05) { this.x += rand(-2,2); return; }
            if (state.dominance === 'SWEET' && Math.random()<0.01) createEmote(this.x, this.y-25, 'ðŸŽµ');
        }

        this.runAI(speedMult);
    }

    runAI(speedMult) { /* Override */ }

    drawBase(color) {
        let s = CONFIG.charSize; let yOff = this.jumpY;
        let dx = this.x | 0; let dy = this.y | 0; // Integer coordinates
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(dx, dy, s/2, s/4, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = color; ctx.fillRect(dx-s/2, dy-s/2+yOff, s, s*1.3);
        ctx.fillStyle = '#ffeaa7'; ctx.beginPath(); ctx.arc(dx, dy-s/2+yOff, s/2, 0, Math.PI*2); ctx.fill();
    }
    
    draw() { this.drawBase('#7f8c8d'); }
}

class Mover extends Character {
    runAI(speedMult) {
        let speed = CONFIG.speed.run * speedMult;
        if(this.state==='IDLE') {
            if (this.backpack.length > 0) {
                if(this.backpack.length < 4) {
                   let next = this.findRawItem();
                   if(next) { this.target = next; this.state='GATHER'; } else { this.state = 'TO_FUNNEL'; } 
                } else { this.state = 'TO_FUNNEL'; }
                return;
            } 
            this.target = this.findRawItem();
            if (this.target) this.state = 'GATHER';
        }
        else if (this.state === 'GATHER') {
            if (!this.target || !state.items.includes(this.target)) { this.state = 'IDLE'; return; }
            this.moveTo(this.target.x, this.target.y, speed, () => {
                if (state.items.includes(this.target)) {
                    this.backpack.push(this.target.color);
                    let idx = state.items.indexOf(this.target);
                    if(idx !== -1) state.items.splice(idx, 1);
                }
                this.target = null;
                this.state = 'IDLE'; 
            });
        }
        else if (this.state === 'TO_FUNNEL') {
            let funnelTop = {x: CONFIG.zones.funnel.x + CONFIG.zones.funnel.w/2, y: CONFIG.zones.funnel.y};
            this.moveTo(funnelTop.x, funnelTop.y, speed, () => {
                if (this.backpack.length > 0) {
                    let chunk = new Item();
                    chunk.initChunk([...this.backpack]);
                    chunk.x = funnelTop.x; chunk.y = funnelTop.y + 20; chunk.stage = 'ON_BELT';
                    state.items.push(chunk);
                    this.backpack = [];
                }
                this.state = 'RETURN';
            });
        }
        else if (this.state === 'RETURN') {
            let base = CONFIG.zones.raw;
            this.moveTo(base.x + rand(10, base.w-10), base.y + rand(10, base.h-10), speed, () => { this.state = 'IDLE'; });
        }
    }

    findRawItem() {
        let closest = null;
        let minDistSq = Infinity;
        for(const i of state.items) {
            if (i.stage==='RAW' && !i.carrier && !i.isChunk && !i.reserved && i.baseColor !== '#1dd1a1' && i.qualityType !== 1) {
                let d2 = distSq(this.x, this.y, i.x, i.y);
                if(d2 < minDistSq) { minDistSq = d2; closest = i; }
            }
        }
        if(closest) closest.reserved = true;
        return closest;
    }

    draw() {
        this.drawBase('#e67e22');
        if(this.backpack.length > 0) {
            let yBase = this.y - CONFIG.charSize - 5 + this.jumpY;
            this.backpack.forEach((c, i) => {
                ctx.fillStyle = c; ctx.beginPath(); ctx.arc(this.x, yBase - (i*4), 4, 0, Math.PI*2); ctx.fill();
            });
        }
    }
}

class Janitor extends Character {
    runAI(speedMult) {
        let speed = CONFIG.speed.run * speedMult;
        if(this.state === 'IDLE') {
            let trashItem = state.items.find(i => i.stage === 'RAW' && !i.carrier && !i.reserved && (i.baseColor === '#1dd1a1' || i.qualityType === 1));
            if (trashItem) { this.target = trashItem; this.target.reserved = true; this.state = 'PICKUP'; }
        }
        else if (this.state === 'PICKUP') {
            if(!this.target || !state.items.includes(this.target)) { this.state = 'IDLE'; return; }
            this.moveTo(this.target.x, this.target.y, speed, () => {
               if(state.items.includes(this.target)) { this.target.carrier = this; this.state = 'TO_TRASH'; } 
               else { this.state = 'IDLE'; }
            });
        }
        else if (this.state === 'TO_TRASH') {
            let tZone = CONFIG.zones.trash;
            this.moveTo(tZone.x + tZone.w/2, tZone.y + tZone.h/2, speed, () => {
                if (this.target) {
                    createParticle(this.x, this.y, '#555', 8); 
                    let idx = state.items.indexOf(this.target);
                    if(idx !== -1) state.items.splice(idx, 1);
                    this.target = null;
                }
                this.state = 'IDLE';
            });
        }
    }
    draw() {
        this.drawBase('#2c3e50');
        ctx.fillStyle = '#555'; ctx.fillRect(this.x-CONFIG.charSize/2, this.y-CONFIG.charSize/2+this.jumpY-3, CONFIG.charSize, 3);
    }
}

class Worker extends Character {
    runAI() {
        let item = state.items.find(i => i.stage==='ON_BELT' && Math.abs(i.x-this.x)<20 && !i.processedBy.has(this.id));
        if(item) {
            item.processedBy.add(this.id);
            if (this.id < 3) item.shape = 'blob'; 
            else if (this.id < 6) item.shape = Math.random()<0.5 ? 'square' : 'circle'; 
            else item.shape = 'star'; 
            createParticle(item.x, item.y, item.ingredients[0], 2);
            this.jump();
        }
    }
    draw() { this.drawBase('#e84393'); }
}

class MonitorSup extends Character {
    runAI() {
        let activeItem = state.monitor.activeItem;
        if (activeItem && state.frame % 30 === 0) {
            if (activeItem.qualityType === 1) { createEmote(this.x, this.y - 20, '!!'); this.jump(); } 
            else if (activeItem.qualityType === 2) { createEmote(this.x, this.y - 20, 'â¤ï¸'); }
        }
    }
    draw() { this.drawBase('#7f8c8d'); }
}

class Decorator extends Character {
    runAI(speedMult) {
        let speed = CONFIG.speed.run * speedMult;
        if(this.state==='IDLE' || this.state==='WAITING') {
            let item = state.items.find(i=>i.stage==='PENDING_DECO' && !i.carrier && !i.reserved);
            if(item) { item.reserved = true; this.target = item; this.state='PICKUP'; return; }
            
            if (this.state !== 'WAITING') {
                 let waitX = CONFIG.zones.decoTable.x + CONFIG.zones.decoTable.w + 20;
                 let waitY = CONFIG.zones.decoTable.y + 20 + (this.id * 15); 
                 let dSq = distSq(this.x, this.y, waitX, waitY);
                 if (dSq > 25) { this.moveTo(waitX, waitY, speed, () => { this.state = 'WAITING'; }); }
            } else {
                 if(Math.random() < 0.02) {
                     const talks = ['ðŸŽ€', 'âœ¨', 'ðŸŽ¨', 'ðŸ¤”', 'ðŸ’Ž', 'ðŸŒˆ', 'ðŸ’'];
                     createEmote(this.x, this.y - 15, talks[Math.floor(Math.random()*talks.length)]);
                 }
            }
        }
        else if(this.state==='PICKUP') {
            if(!this.target) { this.state='IDLE'; return; }
            this.moveTo(this.target.x, this.target.y, speed, ()=>{
                if(this.target) { this.target.carrier = this; this.target.stage = 'ON_TABLE'; this.state = 'TO_TABLE'; } 
                else this.state = 'IDLE';
            });
        }
        else if(this.state==='TO_TABLE') {
            let tx = CONFIG.zones.decoTable.x + 10 + (this.id % 4)*20;
            let ty = CONFIG.zones.decoTable.y + 10 + Math.floor(this.id/4)*40;
            this.moveTo(tx, ty, speed, ()=>{ this.state='DECORATING'; this.timer = 0; });
        }
        else if(this.state==='DECORATING') {
            this.timer++;
            if(this.timer > 30) { 
                if(this.target) { this.target.stage = 'PACKED'; createParticle(this.x, this.y - 15, '#fff', 5); }
                this.state = 'TO_QUEUE'; 
            }
        }
        else if(this.state==='TO_QUEUE') {
            let queueZone = CONFIG.zones.monitorQueue;
            let qx = queueZone.x + rand(5, queueZone.w-10);
            let qy = queueZone.y + rand(5, queueZone.h-5);
            this.moveTo(qx, qy, speed, ()=>{
                if(this.target) { 
                    this.target.carrier = null; this.target.stage = 'WAITING_MONITOR'; 
                    this.target.x = qx; this.target.y = qy; this.target = null; 
                }
                this.state = 'RETURN'; 
            });
        }
        else if(this.state==='RETURN') {
            let base = CONFIG.zones.decoTable;
            this.moveTo(base.x + base.w/2, base.y + base.h + 10, speed, ()=>{ this.state='WAITING'; });
        }
    }
    draw() { this.drawBase('#8e44ad'); }
}

class Deliverer extends Character {
    initPos() {
        this.x = canvas.width + 100 + rand(0,100); 
        this.y = rand(100, 300);
    }
    reset() {
        super.reset(); this.x = -1000;
    }
    runAI(speedMult) {
        if (state.isDay) {
            if (this.x < canvas.width + 150) { this.x += 8; }
            this.target = null; this.state = 'IDLE';
            return;
        }
        if(this.x < 0) {
            this.x = canvas.width + 50 + (this.id * 20); 
            this.y = CONFIG.zones.finish.y + rand(0, 100);
            this.state = 'IDLE';
        }

        let speed = CONFIG.speed.fly * speedMult;
        
        if (this.state === 'IDLE' || this.state === 'RETURN' || this.state === 'WAITING') {
            let job = state.items.find(i => i.stage === 'ON_SHELF' && !i.carrier && !i.reserved);
            if (job) {
                this.target = job; this.target.reserved = true; 
                this.state = 'PICKUP';
                this.destHouse = state.houses[Math.floor(Math.random() * state.houses.length)];
            }
        }

        if (this.state === 'PICKUP') {
            if (!this.target) { this.state = 'IDLE'; return; }
            let dSq = distSq(this.target.x, this.target.y, this.x, this.y);
            if (dSq < 25) {
                if (this.target.slotIndex !== -1) {
                    state.shelfSlots[this.target.slotIndex] = null; 
                    this.target.slotIndex = -1; this.target.carrier = this;
                    this.target.stage = 'DELIVERING'; this.state = 'DELIVER';
                } else { this.state = 'IDLE'; }
            } else { 
                let d = Math.sqrt(dSq);
                this.x += (this.target.x - this.x)/d * speed; 
                this.y += (this.target.y - this.y)/d * speed; 
            }
        }
        else if (this.state === 'DELIVER') {
            if (!this.destHouse) { this.state = 'IDLE'; return; }
            let tx = this.destHouse.win.x + 15; let ty = this.destHouse.win.y; 
            let dSq = distSq(this.x, this.y, tx, ty);
            if (dSq < 25) {
                if (this.target) {
                    this.destHouse.receiveItem(this.target);
                    this.target.carrier = null;
                    let idx = state.items.indexOf(this.target);
                    if(idx !== -1) state.items.splice(idx, 1);
                    this.target = null;
                    createParticle(this.x, this.y, '#f1c40f', 8);
                }
                this.state = 'RETURN';
            } else { 
                let d = Math.sqrt(dSq);
                this.x += (tx - this.x)/d * speed; 
                this.y += (ty - this.y)/d * speed; 
            }
        }
        else {
            // Hovering
            let waitX = CONFIG.zones.finish.x + CONFIG.zones.finish.w + 40 + (this.id % 2) * 30;
            let waitY = CONFIG.zones.finish.y + 20 + (this.id * 25);
            let dSq = distSq(this.x, this.y, waitX, waitY);
            if (dSq > 25) { 
                let d = Math.sqrt(dSq);
                this.x += (waitX - this.x)/d * speed; this.y += (waitY - this.y)/d * speed; this.state = 'RETURN'; 
            } 
            else { this.state = 'IDLE'; this.y += Math.sin(state.frame * 0.1 + this.id) * 0.5; }
        }
    }
    draw() {
        if(this.x < -200) return;
        this.drawBase('#f1c40f');
        let s = CONFIG.charSize; let yOff = this.jumpY;
        ctx.fillStyle = '#333'; ctx.fillRect(this.x-4, this.y-s/2-2+yOff, 8, 3); 
        ctx.fillStyle = '#bdc3c7'; ctx.fillRect(this.x-s/2-2, this.y-s/2+yOff+2, 2, 8);
        if (!state.isDay) {
            ctx.fillStyle = Math.random()>0.5 ? '#e67e22' : '#f1c40f';
            ctx.beginPath(); ctx.moveTo(this.x-s/2, this.y+yOff+8); ctx.lineTo(this.x-s/2-4, this.y+yOff+16 + rand(0,4)); ctx.lineTo(this.x-s/2+2, this.y+yOff+8); ctx.fill();
            if ((this.state === 'IDLE' || this.state === 'RETURN') && state.frame % 20 < 10) {
                 ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y - 15+yOff, 4, 0, Math.PI*2); ctx.stroke();
            }
        }
    }
}

class Office extends Character {
    runAI() {
        if(this.state==='IDLE') {
            if(Math.random()<0.01) {
                let tx = rand(CONFIG.zones.office.x, CONFIG.zones.office.x+CONFIG.zones.office.w);
                let ty = rand(CONFIG.zones.office.y, CONFIG.zones.office.y+CONFIG.zones.office.h);
                this.moveTo(tx, ty, 1, () => this.state='IDLE');
            }
        }
    }
    draw() {
        this.drawBase('#0984e3');
        // Desk & Monitor
        ctx.fillStyle = '#b2bec3'; ctx.fillRect(this.x - 10, this.y + 5, 20, 10);
        ctx.fillStyle = '#2d3436'; ctx.fillRect(this.x - 5, this.y - 2, 10, 8);
        let item = state.monitor.activeItem;
        if (!item) { ctx.fillStyle = '#000'; ctx.fillRect(this.x - 4, this.y - 1, 8, 6); } 
        else {
            let baseColor = item.ingredients[0] || item.color; 
            ctx.fillStyle = baseColor; ctx.fillRect(this.x - 4, this.y - 1, 8, 6);
            if(Math.floor(state.frame/5)%2===0) { ctx.fillStyle = '#fff'; ctx.fillRect(this.x - 4, this.y - 1, 8, 6); }
        }
    }
}

class CEO extends Character {
    runAI() {
        if (this.id === 1) { // Titania
            if (Math.random() < 0.03) createEmote(this.x, this.y - 20, ['ðŸŒ¸', 'ðŸŒº', 'ðŸŒ¼'][Math.floor(Math.random()*3)]);
            state.items.forEach(i => {
                if(i.qualityType === 1 && distSq(this.x, this.y, i.x, i.y) < 10000 && Math.random() < 0.1) {
                    i.qualityType = 2; createParticle(this.x, this.y, '#ff69b4', 5); createEmote(i.x, i.y-20, 'âœ¨');
                }
            });
        } else { // Oberon
            state.pucks.forEach(p => {
                if(p.stunTimer === 0 && distSq(this.x, this.y, p.x, p.y) < 3600) {
                    p.hit(); createEmote(this.x, this.y-30, 'âš”ï¸');
                }
            });
        }
        
        if(this.state === 'IDLE') {
            let spots;
            if (this.id === 1) spots = [ {x: CONFIG.zones.office.x + 50, y: CONFIG.zones.office.y + 60}, {x: CONFIG.zones.ceo.x + 30, y: CONFIG.zones.ceo.y + 40} ];
            else spots = [ {x: CONFIG.zones.monitor.x, y: CONFIG.zones.monitor.y+50}, {x: CONFIG.zones.funnel.x, y: CONFIG.zones.funnel.y+50}, {x: CONFIG.zones.ceo.x+30, y: CONFIG.zones.ceo.y+40} ];
            this.target = spots[Math.floor(Math.random()*spots.length)]; this.state = 'PATROL';
        } else if (this.state === 'PATROL') {
            this.moveTo(this.target.x, this.target.y, 2, () => { this.state = 'WATCHING'; this.timer = 0; });
        } else if (this.state === 'WATCHING') {
            this.timer++; if(this.timer > 150) this.state = 'IDLE';
        }
    }
    draw() {
        this.drawBase(this.id === 1 ? '#ffffff' : '#2d3436');
        let s = CONFIG.charSize; let yOff = this.jumpY;
        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; 
        ctx.beginPath(); ctx.moveTo(this.x-8, this.y-25+yOff); ctx.lineTo(this.x+8, this.y-25+yOff); ctx.stroke();
    }
}

// PuckHuman (Formerly Secretary) - Turns into flying Puck at night
class PuckHuman extends Character {
    runAI(speedMult) {
        // Disappear at night (transforms into Flying Puck)
        if(!state.isDay) {
            this.x = -1000;
            return;
        }
        
        // Return to map if day
        if(state.isDay && this.x < -100) {
            this.x = rand(50, canvas.width-50);
            this.y = rand(50, canvas.height/2);
        }

        let speed = CONFIG.speed.run * 2.5 * speedMult;
        if (this.state === 'PATROL' || this.state === 'PICKUP') this.jumpY = Math.abs(Math.sin(state.frame * 0.4)) * -6; 
        else this.jumpY = 0;
        
        state.items.forEach(item => {
            if (['PENDING_DECO', 'PACKED', 'WAITING_MONITOR', 'MONITORING', 'AUTO_MOVE_TO_SHELF', 'ON_SHELF'].includes(item.stage)) {
                if (distSq(this.x, this.y, item.x, item.y) < 400 && Math.random() < 0.1) item.toggleQuality();
            }
        });

        if(this.state === 'IDLE') {
            this.target = {x: rand(50, canvas.width-50), y: rand(50, canvas.height/2)};
            this.state = 'PATROL';
        } else if (this.state === 'PATROL') {
            this.moveTo(this.target.x, this.target.y, speed, () => { this.state = 'WATCHING'; this.timer = 0; });
        } else if (this.state === 'WATCHING') {
            this.timer++; if(this.timer > 50) this.state = 'IDLE';
        }
    }
    draw() { 
        if(this.x > -100) this.drawBase('#00b894'); 
    }
}


// --- Factory ---
const CharacterFactory = {
    create: (role, id) => {
        switch(role) {
            case 'mover': return new Mover(role, id);
            case 'worker': return new Worker(role, id);
            case 'decorator': return new Decorator(role, id);
            case 'monitorSup': return new MonitorSup(role, id);
            case 'deliverer': return new Deliverer(role, id);
            case 'janitor': return new Janitor(role, id);
            case 'office': return new Office(role, id);
            case 'ceo': return new CEO(role, id);
            case 'puckHuman': return new PuckHuman(role, id);
            default: return new Character(role, id);
        }
    }
};

// --- Initialization ---

function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    let cy = canvas.height * 0.45;
    CONFIG.zones = {
        office:{x:canvas.width/2-200,y:30,w:250,h:100}, 
        ceo:{x:canvas.width/2+80,y:30,w:100,h:80},
        raw: {x: 50, y: cy, w: 100, h: 100},
        trash: {x:60, y:cy+140, w:60, h:50},
        funnel: {x: 200, y: cy-40, w: 50, h: 60},
        belt: {x: 220, y: cy+20, w: 400, h: 40},
        beltEnd: {x: 650, y: cy+20, w: 40, h: 50},
        decoTable: {x: 700, y: cy-20, w: 100, h: 100},
        monitorQueue: {x: 800, y: cy-30, w: 30, h: 100},
        monitor: {x: 840, y: cy-80, w: 100, h: 70},
        monitorPad: {x: 840, y: cy+20, w: 100, h: 40},
        finish: {x: 980, y: cy-50, w: 140, h: 240},
    };

    state.chars = [];
    for(let role in CONFIG.roles) {
        for(let i=0; i<CONFIG.roles[role]; i++) {
            state.chars.push(CharacterFactory.create(role, i));
        }
    }
    
    state.houses = [];
    for(let i=0; i<6; i++) state.houses.push({x: 100 + i*180, y: canvas.height-80, w: 100, h: 80, win:{x:0, y:0}});
    // Init houses win pos
    state.houses.forEach(h => { h.win = {x: h.x+h.w/2-15, y: h.y+30, on:false, timer:0}; 
        h.draw = function() {
            ctx.fillStyle = state.isDay ? '#2c3e50' : '#1a252f'; 
            ctx.fillRect(this.x,this.y,this.w-10,this.h);
            ctx.fillStyle=CONFIG.colors.roof[0]; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x+this.w/2,this.y-20); ctx.lineTo(this.x+this.w,this.y); ctx.fill();
            
            if(this.win.timer>0) this.win.timer--; else this.win.on=false;
            let winColor = state.isDay ? '#87ceeb' : (this.win.on ? this.win.color : 'rgba(0,0,0,0.3)');
            if (state.isDay) { ctx.fillStyle = winColor; ctx.fillRect(this.win.x,this.win.y,30,30); } 
            else if (this.win.on) {
                 ctx.globalAlpha = 0.6; ctx.fillStyle = winColor; ctx.fillRect(this.win.x,this.win.y,30,30);
                 // Performance: simplified win highlight
                 ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(this.win.x,this.win.y,30,30);
                 ctx.globalAlpha = 1.0;
            }
        };
        h.receiveItem = function(item) {
             this.win.on=true; this.win.timer=300; 
             if (item.qualityType === 1) { this.win.color = CONFIG.colors.nightmare; createEmote(this.win.x+15, this.win.y-20, '!!'); }
             else if (item.qualityType === 2) { this.win.color = CONFIG.colors.sweetDream; createEmote(this.win.x+15, this.win.y-20, 'â¤ï¸'); }
             else { this.win.color = item.ingredients[0]; }
        }
    });

    state.pedestrians = Array.from({length:10}, ()=>new Pedestrian());
    state.stars = Array.from({length:50}, ()=>({x:rand(0,canvas.width), y:rand(0,canvas.height/2), size:rand(0.5,2)}));
    
    // Auto start tutorial on first load
    startTutorial();
}

// Re-implementing Pedestrian here for completeness as it wasn't a Character subclass
class Pedestrian {
    constructor() {
        this.x = rand(0, canvas.width); this.y = canvas.height - 40 + rand(-10, 10);
        this.dir = Math.random() < 0.5 ? 1 : -1; this.color = `hsl(${rand(0, 360)}, 70%, 50%)`; this.memoryTimer = rand(20, 60); 
    }
    update() {
        if(!state.isDay) return;
        this.x += this.dir * 0.5;
        if(this.x < -20) this.x = canvas.width+20; if(this.x > canvas.width+20) this.x = -20;
        this.memoryTimer--;
        if (this.memoryTimer <= 0) { 
            let item = new Item(); item.x = this.x; item.y = this.y - 20;
            item.targetRawX = CONFIG.zones.raw.x + rand(10, CONFIG.zones.raw.w - 10);
            item.targetRawY = CONFIG.zones.raw.y + rand(10, CONFIG.zones.raw.h - 10);
            item.stage = 'FLYING_TO_FACTORY'; state.items.push(item);
            this.memoryTimer = rand(10, 50); 
        }
    }
    draw() {
        if(!state.isDay) return;
        ctx.fillStyle = this.color; ctx.fillRect(this.x-5, this.y-15, 10, 15);
        ctx.fillStyle = '#ffeaa7'; ctx.beginPath(); ctx.arc(this.x, this.y-20, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#333'; ctx.fillRect(this.x-4, this.y, 3, 8); ctx.fillRect(this.x+1, this.y, 3, 8);
    }
}

// --- Helper Functions ---

function createParticle(x, y, c, size) {
    if(state.particles.length > 300) return; // Prevent freeze by limiting particles
    state.particles.push({x:x, y:y, vx:rand(-2,2), vy:rand(-2,2), life:30, c:c, type:'p', size:size});
}

function createEmote(x, y, text) {
    if(state.particles.length > 300) return; 
    state.particles.push({x:x, y:y, vy:-1, life:40, text:text, type:'emote'});
}

function showPuckMessage() {
    if(!state.isDay) {
        const msg = puckMessages[Math.floor(Math.random() * puckMessages.length)];
        puckText.innerText = "";
        puckBox.style.display = 'block';
        let i = 0;
        const typeInterval = setInterval(() => {
            if(i < msg.length) {
                puckText.innerText += msg[i];
                i++;
            } else {
                clearInterval(typeInterval);
            }
        }, 50);
        setTimeout(() => { puckBox.style.display = 'none'; }, 4000);
    }
}

function updateStats() {
    if(state.isDay) {
        document.body.style.backgroundColor = CONFIG.colors.dayBG;
        titleElem.className = 'title-day';
        nightDisclaimer.style.display = 'none';
    } else {
        document.body.style.backgroundColor = CONFIG.colors.nightBG;
        titleElem.className = 'title-night';
        nightDisclaimer.style.display = 'block';
    }
    
    // Move Time Marker
    let progress = state.dayTimer / CONFIG.dayLength;
    timeMarker.style.left = `${progress * 100}%`;
    timeMarker.innerText = state.isDay ? 'ðŸŒž' : 'ðŸŒ™';
}

function drawBG() {
    // Draw Zones
    ctx.fillStyle = '#dfe6e9'; // Floor for factory
    // Draw connections
    ctx.strokeStyle = '#b2bec3'; ctx.lineWidth = 10;
    ctx.beginPath(); 
    ctx.moveTo(CONFIG.zones.raw.x+50, CONFIG.zones.raw.y); 
    ctx.lineTo(CONFIG.zones.funnel.x, CONFIG.zones.funnel.y+30);
    ctx.stroke();

    // Draw Zones
    for(let key in CONFIG.zones) {
        let z = CONFIG.zones[key];
        let zx = z.x | 0; let zy = z.y | 0; let zw = z.w | 0; let zh = z.h | 0;
        if(key === 'belt') {
             ctx.fillStyle = CONFIG.colors.belt;
             ctx.fillRect(zx, zy, zw, zh);
             // Belt animation
             ctx.fillStyle = '#7f8c8d';
             let off = (state.frame*CONFIG.speed.belt) | 0;
             for(let i=0; i<zw; i+=20) {
                 ctx.fillRect(zx + (i + off)%zw, zy, 2, zh);
             }
        } else if (key === 'finish') {
            ctx.fillStyle = '#b2bec3'; ctx.fillRect(zx, zy, zw, zh);
            // Shelves
            ctx.fillStyle = '#636e72';
            for(let i=0; i<5; i++) {
                ctx.fillRect(zx, zy + 15 + i*28, zw, 2);
            }
        } else {
            ctx.fillStyle = '#dfe6e9';
            ctx.fillRect(zx, zy, zw, zh);
            ctx.strokeStyle = '#bdc3c7'; ctx.strokeRect(zx, zy, zw, zh);
        }
        
        // Label
        ctx.fillStyle = '#aaa'; ctx.font = '10px sans-serif';
        ctx.fillText(key, zx, zy - 5);
    }
    
    // Stars Optimized
    if(!state.isDay) {
        ctx.fillStyle = '#fff';
        state.stars.forEach(s => {
            // Simplified twinkling: size modulation instead of alpha
            let twinkle = Math.sin(state.frame * 0.1 + s.x) * 0.5 + 1; 
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size * twinkle, 0, Math.PI*2); ctx.fill();
        });
    }
}

function resetGameToDay() {
    state.isDay = true;
    state.dayTimer = 0;
    state.phase = 'PLAYING';
    state.pucks = [];
    state.items = []; 
    state.shelfSlots.fill(null);
    endingOverlay.style.display = 'none';
    state.chars.forEach(c => c.reset());
    state.dominance = 'NEUTRAL';
}

canvas.addEventListener('mousedown', (e) => {
    let rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;
    
    const clickRadSq = 50 * 50; // Increased click radius to 50px (2500)
    if(!state.isDay) {
        state.pucks.forEach(p => { if(distSq(mx, my, p.x, p.y) < clickRadSq) p.hit(); });
    }
    state.items.forEach(i => { if(distSq(mx, my, i.x, i.y) < clickRadSq) i.toggleQuality(); });
});

// --- Main Loop ---

function finishNight() {
    if(state.dominance === 'NEUTRAL') { resetGameToDay(); } 
    else {
        state.phase = 'ENDING'; endingOverlay.style.display = 'flex';
        if(state.dominance === 'NIGHTMARE') { endingOverlay.className = 'end-nightmare'; endTitle.innerText = "SYSTEM ERROR"; endDesc.innerText = "Puck has corrupted the world."; } 
        else { endingOverlay.className = 'end-sweet'; endTitle.innerText = "SWEET DREAMS"; endDesc.innerText = "Titania protected the dreams."; }
        setTimeout(() => { resetGameToDay(); }, 5000);
    }
}

function loop() {
    try {
        if (state.phase === 'ENDING') {
            ctx.clearRect(0,0,canvas.width,canvas.height); drawBG();
            state.chars.forEach(c => { c.update(); c.draw(); });
            requestAnimationFrame(loop); return;
        }
        state.frame++; state.dayTimer++;
        if (state.dayTimer > CONFIG.dayLength) { 
            if(state.isDay) { state.isDay = false; state.dayTimer = 0; state.pucks.push(new Puck()); } 
            else { finishNight(); } // Removed 'return' here to fix freeze
        }
        // Logic continues...
        if(!state.isDay && state.dayTimer > CONFIG.dayLength * 0.66 && state.pucks.length < 3) {
            if(state.frame % 60 === 0) { let p = new Puck(); p.x = state.pucks[0].x; p.y = state.pucks[0].y; state.pucks.push(p); createEmote(p.x, p.y, 'CLONE!'); }
        }
        if (state.frame % 1200 === 0) showPuckMessage();
        updateStats();
        ctx.clearRect(0,0,canvas.width,canvas.height); drawBG();
        state.houses.forEach(h=>h.draw());
        state.pedestrians.forEach(p=> { p.update(); p.draw(); });
        
        // Optimized: Filter out deleted items backwards
        for (let i = state.items.length - 1; i >= 0; i--) {
            let item = state.items[i];
            item.update(); 
            item.draw();
            if(item.stage === 'DELETED') {
                state.items.splice(i, 1);
            }
        }

        state.chars.sort((a,b)=>a.y - b.y); 
        state.chars.forEach(c=>{c.update(1.0); c.draw();}); 
        if(!state.isDay) state.pucks.forEach(p => { p.update(); p.draw(); });
        
        // Optimized: Particle Loop
        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.life--;
            if (p.life <= 0) {
                state.particles.splice(i, 1);
            } else {
                if(p.type==='emote') { p.y+=p.vy; ctx.fillStyle=p.c||'#fff'; ctx.font="bold 20px serif"; ctx.fillText(p.text,p.x,p.y); }
                else { p.x+=p.vx; p.y+=p.vy; ctx.fillStyle=p.c; ctx.globalAlpha=p.life/30; ctx.fillRect(p.x,p.y,2,2); ctx.globalAlpha=1; }
            }
        }
        
        requestAnimationFrame(loop);
    } catch (e) {
        console.error("Game Loop Error:", e);
        // Attempt to restart or just stop safely without freezing UI
    }
}

window.addEventListener('resize',init);
init();
loop();
</script>
</body>
</html>
