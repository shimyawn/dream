<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dream Factory: Final Stable Version</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f8ff; transition: background-color 4s; font-family: 'Courier New', monospace; }
        canvas { display: block; }

        #left-ui {
            position: absolute; top: 20px; left: 20px;
            font-family: 'Press Start 2P', cursive;
            z-index: 10; pointer-events: none;
            text-shadow: 2px 2px 0px #000;
            max-width: 450px;
        }
        #factory-title {
            font-size: 22px; margin: 0 0 15px 0; line-height: 1.4;
            transition: color 2s;
        }
        .title-day { color: hotpink; }
        .title-night { color: #ffffcc; }
        #factory-desc {
            font-size: 14px; color: #636363; line-height: 1.6; 
            font-family: 'Noto Sans KR', sans-serif; font-weight: bold;
            transition: color 2s; text-shadow: none;
        }
        #night-disclaimer { display: none; color: #2ecc71; margin-top: 10px; font-size: 0.9em; }

        /* Controls UI */
        #controls-top {
            position: absolute; top: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 10px;
            z-index: 20;
        }
        .ctrl-btn {
            background: rgba(0,0,0,0.6); border: 2px solid #fff;
            color: #fff; padding: 5px 10px;
            font-family: 'Press Start 2P'; font-size: 12px;
            cursor: pointer; border-radius: 4px;
            transition: all 0.2s;
        }
        .ctrl-btn:hover { background: #fff; color: #000; }
        .ctrl-btn.active { background: #f1c40f; color: #000; border-color: #f1c40f; }

        #level-badge {
            position: absolute; top: 70px; left: 20px;
            background: #2d3436; color: #f1c40f;
            padding: 8px 12px; border-radius: 4px;
            font-family: 'Press Start 2P'; font-size: 12px;
            border: 2px solid #f1c40f; z-index: 10;
        }

        #time-bar-container {
            position: absolute; top: 30px; right: 250px;
            width: 150px; height: 10px;
            background: rgba(0,0,0,0.3); border-radius: 5px;
            z-index: 10; pointer-events: none;
        }
        #time-marker {
            position: absolute; top: -10px; left: 0%;
            font-size: 24px; margin-left: -12px; transition: left 0.1s linear;
        }

        #score-board {
            position: absolute; top: 20px; right: 70px;
            display: flex; flex-direction: column; gap: 5px;
            font-family: 'Press Start 2P', cursive; font-size: 12px;
            z-index: 10; pointer-events: none;
            text-align: right;
        }
        .score-item {
            padding: 8px 12px; border-radius: 4px;
            background: rgba(0, 0, 0, 0.6); color: #fff;
            text-shadow: 1px 1px 0 #000;
            transition: transform 0.2s;
        }
        .score-nightmare { border-left: 4px solid #00ff00; color: #00ff00; }
        .score-sweet { border-left: 4px solid #ff69b4; color: #ff69b4; }
        .score-neutral { border-left: 4px solid #fff; color: #fff; }

        #puck-msg-box {
            position: absolute; display: none; padding: 10px 15px;
            background-color: #000; border: 2px solid #00ff00; color: #00ff00;
            font-family: 'Courier New', monospace; font-weight: bold; 
            font-size: 11px;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.5); z-index: 100; max-width: 300px; pointer-events: none;
        }
        .blink-cursor { animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #ending-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive;
            z-index: 999; text-align: center; pointer-events: none;
        }
        .end-nightmare { background: rgba(0, 20, 0, 0.95); color: #00ff00; }
        .end-sweet { background: rgba(255, 192, 203, 0.95); color: #ff1493; }
        .end-neutral { background: rgba(0, 0, 0, 0.9); color: #fff; }
        #end-title { font-size: 40px; margin-bottom: 20px; text-shadow: 4px 4px 0 #000; }
        #end-desc { font-size: 16px; line-height: 1.6; text-shadow: 2px 2px 0 #000; }

        #help-btn {
            position: absolute; top: 20px; right: 20px;
            width: 36px; height: 36px; border-radius: 50%;
            background: #fff; border: 2px solid #000; font-family: 'Press Start 2P', cursive;
            font-size: 16px; cursor: pointer; z-index: 50;
            box-shadow: 2px 2px 0 #000; transition: transform 0.1s;
            display: flex; align-items: center; justify-content: center;
        }
        #help-btn:active { transform: translate(2px, 2px); box-shadow: none; }

        #tutorial-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); z-index: 200; display: flex;
            justify-content: center; align-items: flex-end; padding-bottom: 80px;
            pointer-events: auto;
        }
        #tutorial-box {
            background: rgba(15, 15, 20, 0.95); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #fff;
            padding: 20px 25px; 
            width: auto; max-width: 420px; min-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center; position: relative;
            backdrop-filter: blur(5px);
            margin: 0 20px;
        }
        #tut-title { 
            margin-top: 0; color: #f1c40f; 
            font-family: 'Press Start 2P'; font-size: 13px;
            margin-bottom: 12px; 
            letter-spacing: -0.5px;
            text-transform: uppercase;
        }
        #tut-text { 
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 14px; line-height: 1.5; color: #eee;
            margin-bottom: 20px; min-height: 42px; font-weight: 400; word-break: keep-all;
        }
        .tut-btn {
            background: rgba(255,255,255,0.1); 
            color: #fff; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px; padding: 6px 14px; 
            font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700;
            cursor: pointer; margin: 0 4px; transition: all 0.2s;
        }
        .tut-btn:hover { background: rgba(255,255,255,0.2); }
        .tut-btn.primary { 
            background: #f1c40f; color: #111; border-color: #f1c40f; 
            box-shadow: 0 2px 10px rgba(241, 196, 15, 0.3);
        }
        .tut-btn.primary:hover { background: #f39c12; border-color: #f39c12; }
        
        #tut-highlight {
            position: absolute; border: 3px solid #f1c40f;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5), inset 0 0 10px rgba(241, 196, 15, 0.2);
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: none; z-index: 199; display: none;
        }
        .tut-hidden { display: none !important; }
        
        #rage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            pointer-events: none; z-index: 5;
            background: rgba(255, 0, 0, 0);
            transition: background 0.5s;
        }
    </style>
</head>
<body>
    <div id="controls-top">
        <button class="ctrl-btn active" onclick="setSpeed(1)">1X</button>
        <button class="ctrl-btn" onclick="setSpeed(2)">2X</button>
        <button class="ctrl-btn" onclick="setSpeed(4)">4X</button>
        <button class="ctrl-btn" onclick="setSpeed(8)">8X</button>
    </div>

    <div id="left-ui">
        <div id="level-badge">LV.1</div>
        <h1 id="factory-title" class="title-day">A Midsummer Night's Dream Factory</h1>
        <div id="factory-desc">
            VIP customer, hello. We are a premium dream factory.
            <div id="night-disclaimer">
                *WARNiNG: Puck intrusion detected.<br>
                *Oberon & Titania are defending.
            </div>
        </div>
    </div>
    <div id="time-bar-container"><div id="time-marker">ðŸŒž</div></div>
    
    <div id="score-board">
        <div class="score-item score-sweet">SWEET: <span id="s-sweet">0</span></div>
        <div class="score-item score-nightmare">NIGHTMARE: <span id="s-nightmare">0</span></div>
        <div class="score-item score-neutral">NEUTRAL: <span id="s-neutral">0</span></div>
    </div>

    <div id="puck-msg-box"><span id="puck-text"></span><span class="blink-cursor">_</span></div>
    <button id="help-btn">?</button>

    <div id="tutorial-overlay">
        <div id="tut-highlight"></div>
        <div id="tutorial-box">
            <h2 id="tut-title">Welcome!</h2>
            <p id="tut-text">Tutorial text goes here.</p>
            <div>
                <button id="tut-skip" class="tut-btn">Skip</button>
                <button id="tut-next" class="tut-btn primary">Next</button>
            </div>
        </div>
    </div>

    <div id="ending-overlay"><h1 id="end-title"></h1><p id="end-desc"></p></div>
    <div id="rage-overlay"></div>
    <canvas id="canvas"></canvas>

<script>
// 1. CONSTANTS & CONFIG
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const titleElem = document.getElementById('factory-title');
const nightDisclaimer = document.getElementById('night-disclaimer');
const timeMarker = document.getElementById('time-marker');
const puckBox = document.getElementById('puck-msg-box');
const puckText = document.getElementById('puck-text');
const endingOverlay = document.getElementById('ending-overlay');
const endTitle = document.getElementById('end-title');
const endDesc = document.getElementById('end-desc');
const rageOverlay = document.getElementById('rage-overlay');
const levelBadge = document.getElementById('level-badge');

const scoreElSweet = document.getElementById('s-sweet');
const scoreElNightmare = document.getElementById('s-nightmare');
const scoreElNeutral = document.getElementById('s-neutral');

const tutOverlay = document.getElementById('tutorial-overlay');
const tutTitle = document.getElementById('tut-title');
const tutText = document.getElementById('tut-text');
const tutNext = document.getElementById('tut-next');
const tutSkip = document.getElementById('tut-skip');
const tutHighlight = document.getElementById('tut-highlight');
const helpBtn = document.getElementById('help-btn');

const rand = (min, max) => Math.random() * (max - min) + min;
const distSq = (x1, y1, x2, y2) => (x2-x1)**2 + (y2-y1)**2; 
const dist = (x1, y1, x2, y2) => Math.sqrt(distSq(x1, y1, x2, y2));

// [MODIFIED] Base speed reduced by half for "1X is slower" request
const CONFIG = {
    dayLength: 2000, 
    charSize: 16,
    speed: { walk: 0.6, run: 1.1, belt: 0.4, autoMove: 1.5, fly: 2.5 }, 
    roles: { mover: 5, janitor: 1, worker: 8, monitorSup: 1, decorator: 8, deliverer: 6, office: 6, ceo: 2, puckHuman: 1 },
    colors: {
        memories: ['#ff9ff3', '#feca57', '#ff6b6b', '#48dbfb', '#1dd1a1', '#5f27cd'], 
        roof: ['#e74c3c', '#8e44ad', '#2980b9'],
        nightmare: '#00ff00', sweetDream: '#ff79cd',      
        belt: '#95a5a6', funnels: '#e17055',
        decoTable: '#95a5a6',
        dayBG: '#f0f8ff', nightBG: '#0f0c29'
    },
    zones: {},
    shelfCapacity: 35,
    deliveryBonus: 500, 
    activeItemScore: 10,
    dialogueInterval: { min: 240, max: 600 } 
};

// --- TUTORIAL DATA ---
const tutorialSteps = [
    { title: "Raw Material", text: "Dream fragments appear here. Movers collect them to start the process.", zone: 'raw' },
    { title: "Processing", text: "Fragments are processed into basic shapes here.", zone: 'funnel' },
    { title: "Assembly", text: "Workers on the belt shape the dreams.", zone: 'belt' },
    { title: "Decoration", text: "Decorators add final touches and emotions here.", zone: 'decoTable' },
    { title: "Quality Control", text: "The Monitor checks quality. Watch out for Green Nightmares!", zone: 'monitor' },
    { title: "Shipping", text: "Finished dreams are stored here before delivery.", zone: 'finish' },
    { title: "Management", text: "Oberon and Titania manage the factory from here.", zone: 'office' },
    { title: "Night Time", text: "At night, Puck invades! Click items to save them, click Puck to stun him.", zone: null }
];
let currentTutStep = 0;
// -------------------------------------------

const puckMessages = [
    "Puck's msg: Click on dreams so soft and fair,\nturn them to a green nightmare.",
    "Puck's msg: ðŸ˜› (Bleh!)",
    "Puck's msg: Is it not a joy to see?\nRuining dreams with wicked glee?",
    "Puck's msg: For happy dreams, if that is your will,\nclick once more, your wish fulfill.",
    "Puck's msg: I am Puck, the system's bug.\nGiving logic a mischievous tug."
];

const DIALOGUES = {
    oberon: [
        "Torment thee not, but let the vision rise.", "Before the morning sun offends our eyes.", "Fetch me that flower, the purple dye of love.", "To paint the clouds that float in skies above.",
        "Silence awhile, and let the code run deep.", "Strike dead the sense of all who are asleep.", "This falls out better than I could devise.", "A perfect glitch within the loverâ€™s eyes.",
        "About the wood go swifter than the wind.", "Then fate oâ€™errules, that one man holding troth.", "Ill met by moonlight, if the scene is wrong.", "Correct the lighting where it distinct belongs.",
        "I know a bank where the wild thyme blows.", "There set the anchor where the user goes.", "Render the passion in the human heart.", "Stand aside, the noise they make is loud."
    ],
    titania: [
        "Come, now a roundel and a fairy song.", "The texture mapping must not take too long.", "Tie up my loverâ€™s tongue, bring him silently.", "The visual grandness is enough for me.",
        "And thy fair virtueâ€™s force perforce doth move me.", "To debug errors and to swear I love thee.", "Methought I was enamored of an ass.", "But change the model, let this nightmare pass.",
        "Feed him with apricocks and dewberries.", "The moon, methinks, looks with a watâ€™ry eye.", "Adjust the bloom before the night goes by.", "Sleep thou, and I will wind thee in my arms.",
        "Music, ho! Music such as charmeth sleep.", "Layers of sound within the dreamy deep.", "These are the forgeries of jealousy.", "Design the motion smooth as best you can."
    ],
    puck: [
        "Iâ€™ll put a girdle round about the earth.", "And compile chaos into happy mirth.", "Lord, what fools these mortals be!", "They click on links they should not see.",
        "Up and down, up and down.", "I will lead the logic up and down.", "If we shadows have offended.", "Just reboot and all is mended.",
        "My mistress with a monster is in love.", "A bugs-filled features fit not for above.", "I am that merry wanderer of the night.", "Who fix the shaders till the morning light.",
        "Here is a villain, drawn and ready.", "Keep the frame rate smooth and steady.", "Swifter than arrow from the Tartarâ€™s bow.", "Iâ€™ll patch the system ere the cock does crow."
    ],
    fairies: [
        "Over hill, over dale.", "We trace the logs without a fail.", "Philomel, with melody.", "Sing in our sweet library.", "Hence, away! Now all is well.",
        "Within the server where we dwell.", "Weaving spiders, come not here.", "Keep the web of code quite clear.", "Ready. And I. And I. And I.", "To polish pixels till we die.",
        "Hail, mortal! Hail!", "We bring the assets without fail.", "And hang a pearl in every cowslipâ€™s ear.", "The detail setting must be crystal clear.",
        "Beetles black, approach not near.", "No bugs allowed in this frontier.", "Trip away, make no stay.", "Meet me at the render bay."
    ],
    craftsmen: [
        "Masters, spread yourselves, the time is tight.", "We must install the screen before the night.", "I will roar you as gently as any sucking dove.", "So no distortion breaks the sound of love.",
        "Some man or other must present Wall.", "Without the hardware, we lose it all.", "Write me a prologue, make it eight and six.", "To tell the audience of our visual tricks.",
        "O grim-looked night! O night with hue so black!", "Where is the cable that I sadly lack?", "There are things in this comedy that will never please.", "Unless we test it with a greater ease.",
        "If he come not, then the play is marred.", "And all our coding will be disregarded.", "It is the wittiest partition that ever I heard.", "Though strictly speaking, 'tis a prop absurd."
    ]
};

// 2. STATE
let state = {
    frame: 0, isDay: true, dayTimer: 0, phase: 'PLAYING',
    stats: { nightmare: 0, sweet: 0, neutral: 0 }, dominance: 'NEUTRAL',
    deliveryScores: { nightmare: 0, sweet: 0, neutral: 0 },
    caughtNightmares: 0, rageMode: false,
    level: 1, timeScale: 1, // [MODIFIED] Added level and timeScale
    items: [], chars: [], houses: [], particles: [], pedestrians: [], dusts: [], stars: [], pucks: [], 
    shelfSlots: new Array(CONFIG.shelfCapacity).fill(null),
    monitor: { activeItem: null, timer: 0 },
    dialogue: { active: null, timer: rand(CONFIG.dialogueInterval.min, CONFIG.dialogueInterval.max) }
};

// 3. DRAWING & UTILS
function setSpeed(scale) {
    state.timeScale = scale;
    document.querySelectorAll('.ctrl-btn').forEach(b => {
        b.classList.remove('active');
        if(b.innerText === scale + 'X') b.classList.add('active');
    });
}

function drawSpeechBubble(ctx, text, x, y, alpha) {
    if(!text) return;
    
    ctx.globalAlpha = alpha;
    ctx.font = "9px 'Noto Sans KR'"; 
    const paddingX = 6; const paddingY = 4;
    const w = ctx.measureText(text).width + paddingX * 2;
    const h = 16; const r = 3;
    
    ctx.fillStyle = "rgba(240, 240, 240, 0.95)";
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;
    
    ctx.beginPath();
    ctx.moveTo(x - w/2 + r, y - h);
    ctx.lineTo(x + w/2 - r, y - h);
    ctx.quadraticCurveTo(x + w/2, y - h, x + w/2, y - h + r);
    ctx.lineTo(x + w/2, y - r);
    ctx.quadraticCurveTo(x + w/2, y, x + w/2 - r, y);
    ctx.lineTo(x - w/2 + r, y);
    ctx.quadraticCurveTo(x - w/2, y, x - w/2, y - r);
    ctx.lineTo(x - w/2, y - h + r);
    ctx.quadraticCurveTo(x - w/2, y - h, x - w/2 + r, y - h);
    ctx.closePath();
    
    ctx.fill(); ctx.stroke();
    
    ctx.fillStyle = "#111";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, x, y - h/2);
    ctx.globalAlpha = 1.0;
}

function drawBG() {
    ctx.fillStyle = '#dfe6e9'; 
    ctx.strokeStyle = '#b2bec3'; ctx.lineWidth = 10;
    ctx.beginPath(); 
    ctx.moveTo(CONFIG.zones.raw.x+50, CONFIG.zones.raw.y); 
    ctx.lineTo(CONFIG.zones.funnel.x, CONFIG.zones.funnel.y+30);
    ctx.stroke();

    for(let key in CONFIG.zones) {
        let z = CONFIG.zones[key];
        let zx = z.x | 0; let zy = z.y | 0; let zw = z.w | 0; let zh = z.h | 0;
        if(key === 'belt') {
             ctx.fillStyle = CONFIG.colors.belt;
             ctx.fillRect(zx, zy, zw, zh);
             ctx.fillStyle = '#7f8c8d';
             let off = (state.frame*CONFIG.speed.belt * state.timeScale) | 0;
             for(let i=0; i<zw; i+=20) { ctx.fillRect(zx + (i + off)%zw, zy, 2, zh); }
        } else if (key === 'finish') {
            ctx.fillStyle = '#b2bec3'; ctx.fillRect(zx, zy, zw, zh);
            ctx.fillStyle = '#636e72';
            for(let i=0; i<5; i++) { ctx.fillRect(zx, zy + 15 + i*28, zw, 2); }
        } else {
            ctx.fillStyle = '#dfe6e9';
            ctx.fillRect(zx, zy, zw, zh);
            ctx.strokeStyle = '#bdc3c7'; ctx.strokeRect(zx, zy, zw, zh);
        }
        ctx.fillStyle = '#aaa'; ctx.font = '10px sans-serif';
        ctx.textAlign = "start";
        ctx.fillText(key, zx, zy - 5);
    }
    
    if(!state.isDay) {
        ctx.fillStyle = '#fff';
        state.stars.forEach(s => {
            let twinkle = Math.sin(state.frame * 0.1 * state.timeScale + s.x) * 0.5 + 1; 
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size * twinkle, 0, Math.PI*2); ctx.fill();
        });
    }
}

function createParticle(x, y, c, size) {
    if(state.particles.length > 300) return;
    state.particles.push({x:x, y:y, vx:rand(-2,2), vy:rand(-2,2), life:30, c:c, type:'p', size:size});
}

function createEmote(x, y, text) {
    if(state.particles.length > 300) return; 
    state.particles.push({x:x, y:y, vy:-1, life:40, text:text, type:'emote'});
}

function showPuckMessage() {
    if(!state.isDay) {
        const msg = puckMessages[Math.floor(Math.random() * puckMessages.length)];
        puckText.innerText = "";
        puckBox.style.display = 'block';
        let i = 0;
        const typeInterval = setInterval(() => {
            if(i < msg.length) {
                puckText.innerText += msg[i];
                i++;
            } else {
                clearInterval(typeInterval);
            }
        }, 50 / state.timeScale); // Faster typing on speed up
        setTimeout(() => { puckBox.style.display = 'none'; }, 4000 / state.timeScale);
    }
}

function updateStats() {
    if(state.isDay) {
        document.body.style.backgroundColor = CONFIG.colors.dayBG;
        titleElem.className = 'title-day';
        nightDisclaimer.style.display = 'none';
    } else {
        document.body.style.backgroundColor = CONFIG.colors.nightBG;
        titleElem.className = 'title-night';
        nightDisclaimer.style.display = 'block';
    }
    
    let progress = state.dayTimer / CONFIG.dayLength;
    timeMarker.style.left = `${progress * 100}%`;
    timeMarker.innerText = state.isDay ? 'ðŸŒž' : 'ðŸŒ™';

    let currentSweet = 0, currentNightmare = 0, currentNeutral = 0;
    for(const item of state.items) {
        if(item.stage === 'DELETED') continue;
        if(item.qualityType === 1) currentNightmare++;
        else if(item.qualityType === 2) currentSweet++;
        else currentNeutral++;
    }

    let finalSweet = state.deliveryScores.sweet + (currentSweet * CONFIG.activeItemScore);
    let finalNightmare = state.deliveryScores.nightmare + (currentNightmare * CONFIG.activeItemScore);
    let finalNeutral = state.deliveryScores.neutral + (currentNeutral * CONFIG.activeItemScore);

    scoreElSweet.innerText = finalSweet;
    scoreElNightmare.innerText = finalNightmare;
    scoreElNeutral.innerText = finalNeutral;
    
    state.stats.sweet = finalSweet;
    state.stats.nightmare = finalNightmare;
    state.stats.neutral = finalNeutral;
}

// ==========================================
// 4. ENTITY CLASSES
// ==========================================

class Puck {
    constructor() {
        this.x = canvas.width/2; 
        this.y = 50; 
        // [MODIFIED] Level Based Speed
        let baseSpeed = 2 + (state.level * 0.5); 
        this.vx = rand(-baseSpeed, baseSpeed); 
        this.vy = rand(2, baseSpeed);
        this.stunTimer = 0;
        this.speech = { text: "", timer: 0 };
    }
    update(dt) { // dt is timeScale
        if (this.speech.timer > 0) this.speech.timer -= dt;
        else if (Math.random() < 0.001 * dt) { 
            this.speech.text = DIALOGUES.puck[Math.floor(Math.random()*DIALOGUES.puck.length)];
            this.speech.timer = 300; 
        }

        if(this.stunTimer > 0) { this.stunTimer -= dt; return; } 
        
        this.x += this.vx * dt; this.y += this.vy * dt;

        const padding = 30;
        if (this.x < padding) { this.x = padding; this.vx *= -1; }
        if (this.x > canvas.width - padding) { this.x = canvas.width - padding; this.vx *= -1; }
        
        if (this.y < padding) { this.y = padding; this.vy = Math.abs(this.vy); } 
        if (this.y > canvas.height - 100) { this.y = canvas.height - 100; this.vy *= -1; }

        if(Math.random() < 0.03 * dt) { 
            let maxS = 2 + (state.level * 0.5);
            this.vx = rand(-maxS, maxS); 
            this.vy = rand(-maxS, maxS); 
            if (Math.abs(this.vx) < 1) this.vx = this.vx < 0 ? -1.5 : 1.5;
            if (Math.abs(this.vy) < 1) this.vy = this.vy < 0 ? -1.5 : 1.5;
        }
        
        // [MODIFIED] Level based Aura Radius
        const auraRadius = 80 + (state.level * 10);
        const auraRadiusSq = auraRadius * auraRadius;
        
        for(let item of state.items) {
            if(item.qualityType !== 1 && distSq(this.x, this.y, item.x, item.y) < auraRadiusSq) {
                // Higher level = faster conversion chance
                if (Math.random() < 0.1 + (state.level * 0.05)) {
                    item.qualityType = 1; 
                    createParticle(item.x, item.y, '#00ff00', 3);
                }
            }
        }
    }
    hit() {
        this.stunTimer = 180; 
        createEmote(this.x, this.y-20, 'ðŸ’«'); 
        createParticle(this.x, this.y, '#ffff00', 10);
    }
    draw() {
        ctx.save(); ctx.translate(this.x | 0, this.y | 0);
        
        let pulse = Math.sin(state.frame * 0.2) * 10;
        let auraSize = (60 + (state.level * 2)) + pulse;
        
        if (this.stunTimer <= 0) {
            let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, auraSize);
            grad.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
            grad.addColorStop(0.5, 'rgba(0, 255, 0, 0.3)');
            grad.addColorStop(1, 'rgba(0, 255, 0, 0)');
            
            ctx.fillStyle = grad; 
            ctx.beginPath(); ctx.arc(0, 0, auraSize, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = 'rgba(50, 255, 50, 0.2)'; 
            ctx.beginPath(); ctx.arc(0, 0, (35 + state.level) + pulse/2, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.rotate(rand(-0.2, 0.2));
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; 
            ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.fill();
        }

        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#00ff00'; ctx.font = "12px serif"; ctx.fillText("ðŸ˜ˆ", -6, 4);
        
        let wingY = this.stunTimer > 0 ? 0 : Math.sin(state.frame * 0.8) * 5;
        ctx.fillStyle = 'rgba(50,255,50,0.8)';
        ctx.beginPath(); ctx.ellipse(-12, -5 + wingY, 12, 6, -0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(12, -5 + wingY, 12, 6, 0.5, 0, Math.PI*2); ctx.fill();
        
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, 0, -30);
        ctx.restore();
    }
}

class Item {
    constructor() {
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = 0; this.y = 0;
        this.baseColor = CONFIG.colors.memories[Math.floor(rand(0, CONFIG.colors.memories.length))];
        this.ingredients = [this.baseColor]; 
        this.color = this.baseColor;
        this.stage = 'RAW'; 
        this.carrier = null;
        this.reserved = false; 
        this.size = 5; 
        this.shape = 'blob'; 
        this.qualityType = 0; 
        this.processedBy = new Set();
        this.slotIndex = -1;
        this.isChunk = false; 
    }
    initChunk(ingredients) {
        this.isChunk = true; this.ingredients = ingredients;
        this.size = 6 + Math.sqrt(ingredients.length) * 2; 
        this.shape = 'blob'; this.color = ingredients[0]; 
    }
    toggleQuality() {
        if (this.qualityType === 0) { 
            this.qualityType = 2; createEmote(this.x, this.y-20, 'â¤ï¸'); 
        }
        else if (this.qualityType === 2) { 
            this.qualityType = 1; createEmote(this.x, this.y-20, '!!'); 
        }
        else { 
            this.qualityType = 0; 
        }
    }
    update(dt) {
        if (this.carrier) { 
            this.x = this.carrier.x; 
            this.y = this.carrier.type === 'deliverer' ? this.carrier.y + 15 : this.carrier.y - 14;
            return; 
        }
        if (this.y > canvas.height + 100) { this.stage = 'DELETED'; }
        
        if (this.stage === 'FLYING_TO_FACTORY') {
            let dSq = distSq(this.x, this.y, this.targetRawX, this.targetRawY);
            if (dSq < 25) { this.stage = 'RAW'; this.x = this.targetRawX; this.y = this.targetRawY; } 
            else { this.x += (this.targetRawX - this.x) * 0.05 * dt; this.y += (this.targetRawY - this.y) * 0.05 * dt; }
        }
        else if (this.stage === 'ON_BELT') {
            this.x += CONFIG.speed.belt * dt; this.y = CONFIG.zones.belt.y + 15;
            if (this.x > CONFIG.zones.belt.x + CONFIG.zones.belt.w) {
                this.stage = 'PENDING_DECO'; 
                this.x = CONFIG.zones.beltEnd.x + rand(0, 30); this.y = CONFIG.zones.beltEnd.y + rand(0, 30);
                this.shape = 'polished'; 
            }
        }
        else if (this.stage === 'WAITING_MONITOR') {
            if (!state.monitor.activeItem) { this.stage = 'MONITORING'; } 
            else { let qx = CONFIG.zones.monitorQueue.x + CONFIG.zones.monitorQueue.w - 15; if (this.x < qx) this.x += 0.5 * dt; }
        }
        else if (this.stage === 'MONITORING') {
            state.monitor.timer += dt; state.monitor.activeItem = this; 
            let targetX = CONFIG.zones.monitorPad.x + CONFIG.zones.monitorPad.w/2;
            let targetY = CONFIG.zones.monitorPad.y + CONFIG.zones.monitorPad.h/2;
            this.x += (targetX - this.x) * 0.2 * dt; this.y += (targetY - this.y) * 0.2 * dt;
            if (state.monitor.timer > 30) { 
                let passed = true;
                if(this.qualityType === 1) { 
                    if(Math.random() < 0.5) {
                        passed = false; 
                        this.stage = 'DELETED';
                        state.caughtNightmares++;
                        let sup = state.chars.find(c => c.type === 'monitorSup');
                        if(sup) { createEmote(sup.x, sup.y - 20, '!!'); sup.jump(); }
                        
                        if(state.caughtNightmares >= 5 && !state.rageMode) {
                            state.rageMode = true;
                            rageOverlay.style.background = "rgba(255, 0, 0, 0.1)";
                            let titania = state.chars.find(c => c.type === 'ceo' && c.id === 1);
                            if(titania) { createEmote(titania.x, titania.y-30, "!!!"); titania.jump(); }
                        }
                    }
                }

                if(passed) {
                    let emptySlot = state.shelfSlots.findIndex(id => id === null);
                    if (emptySlot !== -1) {
                        state.shelfSlots[emptySlot] = this.id; this.slotIndex = emptySlot;
                        this.stage = 'AUTO_MOVE_TO_SHELF';
                    }
                }
                state.monitor.timer = 0; state.monitor.activeItem = null;
            }
        }
        else if (this.stage === 'AUTO_MOVE_TO_SHELF') {
            let row = (this.slotIndex / 5) | 0; let col = this.slotIndex % 5;
            let targetX = CONFIG.zones.finish.x + 15 + col * 22;
            let targetY = CONFIG.zones.finish.y + 15 + row * 28 + 15;
            let dSq = distSq(this.x, this.y, targetX, targetY);
            let threshold = (CONFIG.speed.autoMove + 1)**2;
            if (dSq < threshold) { 
                this.stage = 'ON_SHELF'; this.x = targetX; this.y = targetY; this.reserved = false; 
            }
            else { 
                let d = Math.sqrt(dSq);
                let move = CONFIG.speed.autoMove * dt;
                this.x += (targetX - this.x)/d * move; 
                this.y += (targetY - this.y)/d * move; 
            }
        }
        else if (this.stage === 'ON_SHELF') {
            if (this.slotIndex !== -1) {
                let row = (this.slotIndex / 5) | 0; let col = this.slotIndex % 5;
                this.x = CONFIG.zones.finish.x + 15 + col * 22;
                this.y = CONFIG.zones.finish.y + 15 + row * 28 + 15;
            }
        }
    }
    draw() {
        ctx.save(); ctx.translate(this.x | 0, this.y | 0);
        
        if (this.qualityType === 1) { 
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; ctx.beginPath(); ctx.arc(0,0, this.size+6, 0, Math.PI*2); ctx.fill();
        }
        else if (this.qualityType === 2) { 
            ctx.fillStyle = 'rgba(255, 105, 180, 0.4)'; ctx.beginPath(); ctx.arc(0,0, this.size+6, 0, Math.PI*2); ctx.fill();
        }

        if (['PACKED', 'WAITING_MONITOR', 'MONITORING', 'AUTO_MOVE_TO_SHELF', 'ON_SHELF', 'DELIVERING'].includes(this.stage) || (this.carrier && this.stage === 'PACKED')) {
            ctx.fillStyle = this.ingredients[0]; ctx.fillRect(-6, -6, 12, 12);
            ctx.fillStyle = '#fff'; ctx.fillRect(-2, -6, 4, 12); ctx.fillRect(-6, -2, 12, 4);
            ctx.strokeStyle = '#fff'; ctx.lineWidth=1; ctx.strokeRect(-6,-6,12,12);
            ctx.restore(); return;
        }
        if (this.stage === 'DELETED') { ctx.restore(); return; }
        if (this.isChunk) {
            let radius = this.size * (this.carrier ? 0.8 : 1);
            ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); 
            if(this.ingredients.length > 1) {
                let grad = ctx.createLinearGradient(-radius, -radius, radius, radius);
                this.ingredients.forEach((c, i) => grad.addColorStop(i/(this.ingredients.length-1), c));
                ctx.fillStyle = grad;
            } else { ctx.fillStyle = this.ingredients[0]; }
            ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.4)'; for(let i=0; i<3; i++) ctx.fillRect(rand(-3,3), rand(-3,3), 2, 2);
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill();
        }
        ctx.restore();
    }
}

class Pedestrian {
    constructor() {
        this.x = rand(0, canvas.width); this.y = canvas.height - 40 + rand(-10, 10);
        this.dir = Math.random() < 0.5 ? 1 : -1; this.color = `hsl(${rand(0, 360)}, 70%, 50%)`; 
        this.memoryTimer = rand(100, 200); 
    }
    update(dt) {
        this.x += this.dir * 0.5 * dt;
        if(this.x < -20) this.x = canvas.width+20; if(this.x > canvas.width+20) this.x = -20;
        this.memoryTimer -= dt;
        if (this.memoryTimer <= 0) { 
            let item = new Item(); item.x = this.x; item.y = this.y - 20;
            item.targetRawX = CONFIG.zones.raw.x + rand(10, CONFIG.zones.raw.w - 10);
            item.targetRawY = CONFIG.zones.raw.y + rand(10, CONFIG.zones.raw.h - 10);
            item.stage = 'FLYING_TO_FACTORY'; state.items.push(item);
            this.memoryTimer = rand(100, 200); 
        }
    }
    draw() {
        ctx.fillStyle = this.color; ctx.fillRect(this.x-5, this.y-15, 10, 15);
        ctx.fillStyle = '#ffeaa7'; ctx.beginPath(); ctx.arc(this.x, this.y-20, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#333'; ctx.fillRect(this.x-4, this.y, 3, 8); ctx.fillRect(this.x+1, this.y, 3, 8);
    }
}

class Character {
    constructor(type, id) {
        this.type = type; this.id = id;
        this.x = 0; this.y = 0;
        this.target = null; this.state = 'IDLE'; 
        this.timer = 0; this.jumpY = 0; this.jumpV = 0;
        this.backpack = []; 
        this.speech = { text: "", timer: 0 };
        this.initPos();
    }

    initPos() {
        if(this.type === 'worker') { this.x = CONFIG.zones.belt.x + CONFIG.charSize*2 + this.id * 50; this.y = CONFIG.zones.belt.y + 45; }
        else if (this.type === 'monitorSup') { this.x = CONFIG.zones.monitor.x + 120; this.y = CONFIG.zones.monitor.y + 80; }
        else if (this.type === 'office') { this.x = CONFIG.zones.office.x + 30 + (this.id%3)*60; this.y = CONFIG.zones.office.y + 40 + Math.floor(this.id/3)*50; }
        else { this.x = CONFIG.zones.raw.x; this.y = CONFIG.zones.raw.y; }
    }

    reset() { this.target = null; this.state = 'IDLE'; this.timer = 0; this.backpack = []; this.jumpY=0; this.jumpV=0; }
    jump() { if(this.jumpY === 0) this.jumpV = -6; }
    
    moveTo(tx, ty, spd, onComplete) {
        let dSq = distSq(this.x, this.y, tx, ty);
        if(dSq < 25) { if(onComplete) onComplete(); } 
        else { 
            let d = Math.sqrt(dSq);
            this.x += (tx - this.x)/d * spd; this.y += (ty - this.y)/d * spd; 
        }
    }
    
    update(dt) {
        if (this.speech.timer > 0) this.speech.timer -= dt;
        else if (Math.random() < 0.001 * dt) { 
            let key = '';
            if(this.type === 'ceo') key = this.id === 0 ? 'oberon' : 'titania';
            else if(this.type === 'puckHuman') key = 'puck';
            else if(['mover','decorator','monitorSup'].includes(this.type)) key = 'fairies';
            else key = 'craftsmen';
            
            if(DIALOGUES[key]) {
                this.speech.text = DIALOGUES[key][Math.floor(Math.random()*DIALOGUES[key].length)];
                this.speech.timer = 300;
            }
        }

        if (this.jumpV !== 0 || this.jumpY !== 0) {
            this.jumpY += this.jumpV * dt; this.jumpV += 0.5 * dt; if(this.jumpY >= 0) { this.jumpY = 0; this.jumpV = 0; }
        }
        
        if (!state.isDay) {
            if (state.dominance === 'NIGHTMARE' && Math.random()<0.05 * dt) { this.x += rand(-2,2); return; }
            if (state.dominance === 'SWEET' && Math.random()<0.01 * dt) createEmote(this.x, this.y-25, 'ðŸŽµ');
        }

        this.runAI(dt);
    }

    runAI(dt) { /* Override */ }

    drawBase(color) {
        let s = CONFIG.charSize; let yOff = this.jumpY;
        let dx = this.x | 0; let dy = this.y | 0;
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(dx, dy, s/2, s/4, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = color; ctx.fillRect(dx-s/2, dy-s/2+yOff, s, s*1.3);
        ctx.fillStyle = '#ffeaa7'; ctx.beginPath(); ctx.arc(dx, dy-s/2+yOff, s/2, 0, Math.PI*2); ctx.fill();
    }
    
    draw() { 
        this.drawBase('#7f8c8d'); 
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y - 25);
    }
}

class Mover extends Character {
    runAI(dt) {
        let speed = CONFIG.speed.run * dt;
        if(this.state==='IDLE') {
            if (this.backpack.length > 0) {
                if(this.backpack.length < 4) {
                   let next = this.findRawItem();
                   if(next) { this.target = next; this.state='GATHER'; } else { this.state = 'TO_FUNNEL'; } 
                } else { this.state = 'TO_FUNNEL'; }
                return;
            } 
            this.target = this.findRawItem();
            if (this.target) this.state = 'GATHER';
        }
        else if (this.state === 'GATHER') {
            if (!this.target || !state.items.includes(this.target)) { this.state = 'IDLE'; return; }
            this.moveTo(this.target.x, this.target.y, speed, () => {
                if (state.items.includes(this.target)) {
                    this.backpack.push(this.target.color);
                    let idx = state.items.indexOf(this.target);
                    if(idx !== -1) state.items.splice(idx, 1);
                }
                this.target = null;
                this.state = 'IDLE'; 
            });
        }
        else if (this.state === 'TO_FUNNEL') {
            let funnelTop = {x: CONFIG.zones.funnel.x + CONFIG.zones.funnel.w/2, y: CONFIG.zones.funnel.y};
            this.moveTo(funnelTop.x, funnelTop.y, speed, () => {
                if (this.backpack.length > 0) {
                    let chunk = new Item();
                    chunk.initChunk([...this.backpack]);
                    chunk.x = funnelTop.x; chunk.y = funnelTop.y + 20; chunk.stage = 'ON_BELT';
                    state.items.push(chunk);
                    this.backpack = [];
                }
                this.state = 'RETURN';
            });
        }
        else if (this.state === 'RETURN') {
            let base = CONFIG.zones.raw;
            this.moveTo(base.x + rand(10, base.w-10), base.y + rand(10, base.h-10), speed, () => { this.state = 'IDLE'; });
        }
    }

    findRawItem() {
        let closest = null;
        let minDistSq = Infinity;
        for(const i of state.items) {
            if (i.stage==='RAW' && !i.carrier && !i.isChunk && !i.reserved && i.baseColor !== '#1dd1a1' && i.qualityType !== 1) {
                let d2 = distSq(this.x, this.y, i.x, i.y);
                if(d2 < minDistSq) { minDistSq = d2; closest = i; }
            }
        }
        if(closest) closest.reserved = true;
        return closest;
    }

    draw() {
        this.drawBase('#e67e22');
        if(this.backpack.length > 0) {
            let yBase = this.y - CONFIG.charSize - 5 + this.jumpY;
            this.backpack.forEach((c, i) => {
                ctx.fillStyle = c; ctx.beginPath(); ctx.arc(this.x, yBase - (i*4), 4, 0, Math.PI*2); ctx.fill();
            });
        }
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y - 25);
    }
}

class Janitor extends Character {
    runAI(dt) {
        let speed = CONFIG.speed.run * dt;
        if(this.state === 'IDLE') {
            if (this.backpack.length >= 10) { this.state = 'TO_TRASH'; return; }
            
            let trashItem = state.items.find(i => i.stage === 'RAW' && !i.carrier && !i.reserved && (i.baseColor === '#1dd1a1' || i.qualityType === 1));
            
            if (trashItem) { 
                this.target = trashItem; 
                this.target.reserved = true; 
                this.state = 'PICKUP'; 
            } else if (this.backpack.length > 0) {
                this.state = 'TO_TRASH';
            }
        }
        else if (this.state === 'PICKUP') {
            if(!this.target || !state.items.includes(this.target)) { this.state = 'IDLE'; return; }
            this.moveTo(this.target.x, this.target.y, speed, () => {
               if(state.items.includes(this.target)) { 
                   this.backpack.push(1); 
                   let idx = state.items.indexOf(this.target);
                   if(idx !== -1) state.items.splice(idx, 1);
                   this.target = null;
                   this.state = 'IDLE'; 
               } 
               else { this.state = 'IDLE'; }
            });
        }
        else if (this.state === 'TO_TRASH') {
            let tZone = CONFIG.zones.trash;
            this.moveTo(tZone.x + tZone.w/2, tZone.y + tZone.h/2, speed, () => {
                if (this.backpack.length > 0) {
                    createParticle(this.x, this.y, '#555', 8); 
                    this.backpack = []; 
                }
                this.state = 'IDLE';
            });
        }
    }
    draw() {
        this.drawBase('#2c3e50');
        ctx.fillStyle = '#555'; ctx.fillRect(this.x-CONFIG.charSize/2, this.y-CONFIG.charSize/2+this.jumpY-3, CONFIG.charSize, 3);
        if(this.backpack.length > 0) {
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(this.x+8, this.y+5, 3 + (this.backpack.length/2), 0, Math.PI*2); ctx.fill();
        }
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y - 25);
    }
}

class Worker extends Character {
    runAI(dt) {
        let item = state.items.find(i => i.stage==='ON_BELT' && Math.abs(i.x-this.x)<20 && !i.processedBy.has(this.id));
        if(item) {
            item.processedBy.add(this.id);
            if (this.id < 3) item.shape = 'blob'; 
            else if (this.id < 6) item.shape = Math.random()<0.5 ? 'square' : 'circle'; 
            else item.shape = 'star'; 
            createParticle(item.x, item.y, item.ingredients[0], 2);
            this.jump();
        }
    }
    draw() { 
        this.drawBase('#e84393'); 
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y + 30);
    }
}

class MonitorSup extends Character {
    runAI(dt) {
        let activeItem = state.monitor.activeItem;
        if (activeItem && state.frame % 30 === 0) {
            if (activeItem.qualityType === 1) { createEmote(this.x, this.y - 20, '!!'); this.jump(); } 
            else if (activeItem.qualityType === 2) { createEmote(this.x, this.y - 20, 'â¤ï¸'); }
        }
    }
    draw() { 
        this.drawBase('#7f8c8d'); 
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y - 25);
    }
}

class Decorator extends Character {
    runAI(dt) {
        let speed = state.rageMode ? CONFIG.speed.run * 3.0 : CONFIG.speed.run * dt;
        
        if(state.rageMode) {
            state.items.forEach(item => {
               if(item.qualityType !== 2 && distSq(this.x, this.y, item.x, item.y) < 2500) {
                   item.qualityType = 2; 
                   createParticle(item.x, item.y, '#ff69b4', 5);
               } 
            });
        }

        if(this.state==='IDLE' || this.state==='WAITING') {
            let item = state.items.find(i=>i.stage==='PENDING_DECO' && !i.carrier && !i.reserved);
            if(item) { item.reserved = true; this.target = item; this.state='PICKUP'; return; }
            
            if (this.state !== 'WAITING') {
                 let waitX = CONFIG.zones.decoTable.x + CONFIG.zones.decoTable.w + 20;
                 let waitY = CONFIG.zones.decoTable.y + 20 + (this.id * 15); 
                 let dSq = distSq(this.x, this.y, waitX, waitY);
                 if (dSq > 25) { this.moveTo(waitX, waitY, speed, () => { this.state = 'WAITING'; }); }
            } else {
                 if(Math.random() < 0.02 * dt) {
                     const talks = ['ðŸŽ€', 'âœ¨', 'ðŸŽ¨', 'ðŸ¤”', 'ðŸ’Ž', 'ðŸŒˆ', 'ðŸ’'];
                     createEmote(this.x, this.y - 15, talks[Math.floor(Math.random()*talks.length)]);
                 }
            }
        }
        else if(this.state==='PICKUP') {
            if(!this.target) { this.state='IDLE'; return; }
            this.moveTo(this.target.x, this.target.y, speed, ()=>{
                if(this.target) { this.target.carrier = this; this.target.stage = 'ON_TABLE'; this.state = 'TO_TABLE'; } 
                else this.state = 'IDLE';
            });
        }
        else if(this.state==='TO_TABLE') {
            let tx = CONFIG.zones.decoTable.x + 10 + (this.id % 4)*20;
            let ty = CONFIG.zones.decoTable.y + 10 + Math.floor(this.id/4)*40;
            this.moveTo(tx, ty, speed, ()=>{ this.state='DECORATING'; this.timer = 0; });
        }
        else if(this.state==='DECORATING') {
            this.timer += dt;
            if(this.timer > (state.rageMode ? 5 : 30)) { 
                if(this.target) { this.target.stage = 'PACKED'; createParticle(this.x, this.y - 15, '#fff', 5); }
                this.state = 'TO_QUEUE'; 
            }
        }
        else if(this.state==='TO_QUEUE') {
            let queueZone = CONFIG.zones.monitorQueue;
            let qx = queueZone.x + rand(5, queueZone.w-10);
            let qy = queueZone.y + rand(5, queueZone.h-5);
            this.moveTo(qx, qy, speed, ()=>{
                if(this.target) { 
                    this.target.carrier = null; this.target.stage = 'WAITING_MONITOR'; 
                    this.target.x = qx; this.target.y = qy; this.target = null; 
                }
                this.state = 'RETURN'; 
            });
        }
        else if(this.state==='RETURN') {
            let base = CONFIG.zones.decoTable;
            this.moveTo(base.x + base.w/2, base.y + base.h + 10, speed, ()=>{ this.state='WAITING'; });
        }
    }
    draw() { 
        this.drawBase('#8e44ad');
        if(state.rageMode) { 
            ctx.fillStyle = rand(0,1)>0.5?'#e74c3c':'#f1c40f';
            ctx.beginPath(); ctx.moveTo(this.x-5, this.y-25); ctx.lineTo(this.x, this.y-40); ctx.lineTo(this.x+5, this.y-25); ctx.fill();
        }
    }
}

class Deliverer extends Character {
    initPos() {
        this.x = canvas.width + 100 + rand(0,100); 
        this.y = rand(100, 300);
    }
    reset() {
        super.reset(); this.x = -1000;
    }
    runAI(dt) {
        if (state.isDay) {
            if (this.x < canvas.width + 150) { this.x += 8 * dt; }
            this.target = null; this.state = 'IDLE';
            return;
        }
        if(this.x < 0) {
            this.x = canvas.width + 50 + (this.id * 20); 
            this.y = CONFIG.zones.finish.y + rand(0, 100);
            this.state = 'IDLE';
        }

        let speed = CONFIG.speed.fly * dt;
        
        if (this.state === 'IDLE' || this.state === 'RETURN' || this.state === 'WAITING') {
            let job = state.items.find(i => i.stage === 'ON_SHELF' && !i.carrier && !i.reserved);
            if (job) {
                this.target = job; this.target.reserved = true; 
                this.state = 'PICKUP';
                this.destHouse = state.houses[Math.floor(Math.random() * state.houses.length)];
            }
        }

        if (this.state === 'PICKUP') {
            if (!this.target) { this.state = 'IDLE'; return; }
            let dSq = distSq(this.target.x, this.target.y, this.x, this.y);
            if (dSq < 25) {
                if (this.target.slotIndex !== -1) {
                    state.shelfSlots[this.target.slotIndex] = null; 
                    this.target.slotIndex = -1; this.target.carrier = this;
                    this.target.stage = 'DELIVERING'; this.state = 'DELIVER';
                } else { this.state = 'IDLE'; }
            } else { 
                let d = Math.sqrt(dSq);
                this.x += (this.target.x - this.x)/d * speed; 
                this.y += (this.target.y - this.y)/d * speed; 
            }
        }
        else if (this.state === 'DELIVER') {
            if (!this.destHouse) { this.state = 'IDLE'; return; }
            let tx = this.destHouse.win.x + 15; let ty = this.destHouse.win.y; 
            let dSq = distSq(this.x, this.y, tx, ty);
            if (dSq < 25) {
                if (this.target) {
                    const qType = this.target.qualityType;
                    this.destHouse.receiveItem(this.target);
                    this.target.carrier = null;
                    let idx = state.items.indexOf(this.target);
                    if(idx !== -1) state.items.splice(idx, 1);
                    this.target = null;
                    createParticle(this.x, this.y, '#f1c40f', 8);
                    
                    if(qType === 1) state.deliveryScores.nightmare += CONFIG.deliveryBonus;
                    else if(qType === 2) state.deliveryScores.sweet += CONFIG.deliveryBonus;
                    else state.deliveryScores.neutral += CONFIG.deliveryBonus;
                }
                this.state = 'RETURN';
            } else { 
                let d = Math.sqrt(dSq);
                this.x += (tx - this.x)/d * speed; 
                this.y += (ty - this.y)/d * speed; 
            }
        }
        else {
            let waitX = CONFIG.zones.finish.x + CONFIG.zones.finish.w + 40 + (this.id % 2) * 30;
            let waitY = CONFIG.zones.finish.y + 20 + (this.id * 25);
            let dSq = distSq(this.x, this.y, waitX, waitY);
            if (dSq > 25) { 
                let d = Math.sqrt(dSq);
                this.x += (waitX - this.x)/d * speed; this.y += (waitY - this.y)/d * speed; this.state = 'RETURN'; 
            } 
            else { this.state = 'IDLE'; this.y += Math.sin(state.frame * 0.1 + this.id) * 0.5 * dt; }
        }
    }
    draw() {
        if(this.x < -200) return;
        this.drawBase('#f1c40f');
        let s = CONFIG.charSize; let yOff = this.jumpY;
        ctx.fillStyle = '#333'; ctx.fillRect(this.x-4, this.y-s/2-2+yOff, 8, 3); 
        ctx.fillStyle = '#bdc3c7'; ctx.fillRect(this.x-s/2-2, this.y-s/2+yOff+2, 2, 8);
        if (!state.isDay) {
            ctx.fillStyle = Math.random()>0.5 ? '#e67e22' : '#f1c40f';
            ctx.beginPath(); ctx.moveTo(this.x-s/2, this.y+yOff+8); ctx.lineTo(this.x-s/2-4, this.y+yOff+16 + rand(0,4)); ctx.lineTo(this.x-s/2+2, this.y+yOff+8); ctx.fill();
            if ((this.state === 'IDLE' || this.state === 'RETURN') && state.frame % 20 < 10) {
                 ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y - 15+yOff, 4, 0, Math.PI*2); ctx.stroke();
            }
        }
    }
}

class Office extends Character {
    runAI(dt) {
        if(this.state==='IDLE') {
            if (Math.random()<0.01 * dt) {
                let tx = rand(CONFIG.zones.office.x, CONFIG.zones.office.x+CONFIG.zones.office.w);
                let ty = rand(CONFIG.zones.office.y, CONFIG.zones.office.y+CONFIG.zones.office.h);
                this.moveTo(tx, ty, 1 * dt, () => this.state='IDLE');
            }
        }
    }
    draw() {
        this.drawBase('#0984e3');
        // Desk & Monitor
        ctx.fillStyle = '#b2bec3'; ctx.fillRect(this.x - 10, this.y + 5, 20, 10);
        ctx.fillStyle = '#2d3436'; ctx.fillRect(this.x - 5, this.y - 2, 10, 8);
        let item = state.monitor.activeItem;
        if (!item) { ctx.fillStyle = '#000'; ctx.fillRect(this.x - 4, this.y - 1, 8, 6); } 
        else {
            let baseColor = item.ingredients[0] || item.color; 
            ctx.fillStyle = baseColor; ctx.fillRect(this.x - 4, this.y - 1, 8, 6);
            if(Math.floor(state.frame/5)%2===0) { ctx.fillStyle = '#fff'; ctx.fillRect(this.x - 4, this.y - 1, 8, 6); }
        }
    }
}

class CEO extends Character {
    runAI(dt) {
        if (this.id === 0) { // Oberon
            state.items.forEach(i => {
                if(i.stage === 'ON_SHELF' && i.qualityType !== 0 && distSq(this.x, this.y, i.x, i.y) < 1600) {
                    if(Math.random() < 0.05 * dt) {
                        i.qualityType = 0; 
                        createEmote(i.x, i.y-20, 'âš–ï¸');
                    }
                }
            });
        }

        if (this.id === 1) { // Titania
            if(state.rageMode) {
                let speed = CONFIG.speed.run * 3.0 * dt;
                state.items.forEach(i => {
                    if(i.qualityType !== 2 && distSq(this.x, this.y, i.x, i.y) < 3600) {
                        i.qualityType = 2; 
                        createParticle(i.x, i.y, '#ff69b4', 5);
                    }
                });
                if(Math.random() < 0.1 * dt) {
                    this.target = {x: rand(0, canvas.width), y: rand(0, canvas.height)};
                    this.state = 'RAGE_MOVE';
                }
                if(this.state === 'RAGE_MOVE') {
                    this.moveTo(this.target.x, this.target.y, speed, () => { this.state = 'IDLE'; });
                }
                return; 
            }

            if (Math.random() < 0.03 * dt) createEmote(this.x, this.y - 20, ['ðŸŒ¸', 'ðŸŒº', 'ðŸŒ¼'][Math.floor(Math.random()*3)]);
            state.items.forEach(i => {
                if(i.qualityType === 1 && distSq(this.x, this.y, i.x, i.y) < 10000 && Math.random() < 0.1 * dt) {
                    i.qualityType = 2; createParticle(this.x, this.y, '#ff69b4', 5); createEmote(i.x, i.y-20, 'âœ¨');
                }
            });
        } else { // Oberon combat
            state.pucks.forEach(p => {
                if(p.stunTimer === 0 && distSq(this.x, this.y, p.x, p.y) < 3600) {
                    p.hit(); createEmote(this.x, this.y-30, 'âš”ï¸');
                }
            });
        }
        
        if(this.state === 'IDLE') {
            let spots;
            if (this.id === 1) spots = [ {x: CONFIG.zones.office.x + 50, y: CONFIG.zones.office.y + 60}, {x: CONFIG.zones.ceo.x + 30, y: CONFIG.zones.ceo.y + 40} ];
            else spots = [ {x: CONFIG.zones.monitor.x, y: CONFIG.zones.monitor.y+50}, {x: CONFIG.zones.funnel.x, y: CONFIG.zones.funnel.y+50}, {x: CONFIG.zones.ceo.x+30, y: CONFIG.zones.ceo.y+40}, {x: CONFIG.zones.finish.x+50, y: CONFIG.zones.finish.y+100} ];
            this.target = spots[Math.floor(Math.random()*spots.length)]; this.state = 'PATROL';
        } else if (this.state === 'PATROL') {
            this.moveTo(this.target.x, this.target.y, 2 * dt, () => { this.state = 'WATCHING'; this.timer = 0; });
        } else if (this.state === 'WATCHING') {
            this.timer += dt; if(this.timer > 150) this.state = 'IDLE';
        }
    }
    draw() {
        this.drawBase(this.id === 1 ? '#ffffff' : '#2d3436');
        let s = CONFIG.charSize; let yOff = this.jumpY;
        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; 
        ctx.beginPath(); ctx.moveTo(this.x-8, this.y-25+yOff); ctx.lineTo(this.x+8, this.y-25+yOff); ctx.stroke();
        
        if(this.id === 1 && state.rageMode) {
            ctx.fillStyle = rand(0,1)>0.5?'#e74c3c':'#f1c40f';
            ctx.beginPath(); ctx.moveTo(this.x-5, this.y-30); ctx.lineTo(this.x, this.y-45); ctx.lineTo(this.x+5, this.y-30); ctx.fill();
        }
        
        if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y - 40);
    }
}

class PuckHuman extends Character {
    runAI(dt) {
        if(!state.isDay) { this.x = -1000; return; }
        if(state.isDay && this.x < -100) { this.x = rand(50, canvas.width-50); this.y = rand(50, canvas.height/2); }

        let speed = CONFIG.speed.run * 2.5 * dt;
        if (this.state === 'PATROL' || this.state === 'PICKUP') this.jumpY = Math.abs(Math.sin(state.frame * 0.4)) * -6; 
        else this.jumpY = 0;
        
        state.items.forEach(item => {
            if (['PENDING_DECO', 'PACKED', 'WAITING_MONITOR', 'MONITORING', 'AUTO_MOVE_TO_SHELF', 'ON_SHELF'].includes(item.stage)) {
                if (distSq(this.x, this.y, item.x, item.y) < 400 && Math.random() < 0.1 * dt) item.toggleQuality();
            }
        });

        if(this.state === 'IDLE') {
            this.target = {x: rand(50, canvas.width-50), y: rand(50, canvas.height/2)};
            this.state = 'PATROL';
        } else if (this.state === 'PATROL') {
            this.moveTo(this.target.x, this.target.y, speed, () => { this.state = 'WATCHING'; this.timer = 0; });
        } else if (this.state === 'WATCHING') {
            this.timer += dt; if(this.timer > 50) this.state = 'IDLE';
        }
    }
    draw() { 
        if(this.x > -100) {
            this.drawBase('#00b894'); 
            if (this.speech.timer > 0) drawSpeechBubble(ctx, this.speech.text, this.x, this.y - 40);
        }
    }
}

const CharacterFactory = {
    create: (role, id) => {
        switch(role) {
            case 'mover': return new Mover(role, id);
            case 'worker': return new Worker(role, id);
            case 'decorator': return new Decorator(role, id);
            case 'monitorSup': return new MonitorSup(role, id);
            case 'deliverer': return new Deliverer(role, id);
            case 'janitor': return new Janitor(role, id);
            case 'office': return new Office(role, id);
            case 'ceo': return new CEO(role, id);
            case 'puckHuman': return new PuckHuman(role, id);
            default: return new Character(role, id);
        }
    }
};

// ==========================================
// 5. MAIN LOOP & INIT
// ==========================================

function updateDialogueSystem(dt) {
    if (state.dialogue.active) {
        state.dialogue.active.life -= dt;
        if(state.dialogue.active.life < 20) {
            state.dialogue.active.alpha = state.dialogue.active.life / 20;
        } else if (state.dialogue.active.life > 280) {
            state.dialogue.active.alpha = (300 - state.dialogue.active.life) / 20;
        } else {
            state.dialogue.active.alpha = 1;
        }
        
        if (state.dialogue.active.life <= 0) {
            state.dialogue.active = null;
            state.dialogue.timer = rand(CONFIG.dialogueInterval.min, CONFIG.dialogueInterval.max);
        }
        return;
    }

    state.dialogue.timer -= dt;
    if (state.dialogue.timer <= 0) {
        let availableRoles = [];
        if (state.isDay) {
            availableRoles.push('mover', 'worker', 'decorator', 'monitorSup', 'deliverer', 'janitor', 'office', 'puckHuman');
        }
        availableRoles.push('ceo'); 
        if (!state.isDay) {
            availableRoles.push('puck');
        }

        let role = availableRoles[Math.floor(Math.random() * availableRoles.length)];
        let key = '';
        let targetObj = null; 
        let fixedX = 0, fixedY = 0;

        if (role === 'ceo') {
            let ceo = state.chars.filter(c => c.type === 'ceo')[Math.floor(Math.random() * 2)];
            if(ceo) {
                key = ceo.id === 0 ? 'oberon' : 'titania';
                targetObj = ceo;
            }
        } else if (role === 'puckHuman') {
             let ph = state.chars.find(c => c.type === 'puckHuman');
             if(ph && ph.x > 0) { key = 'puck'; targetObj = ph; }
        } else if (role === 'puck') {
             if(state.pucks.length > 0) { key = 'puck'; targetObj = state.pucks[0]; }
        } else {
            if(['mover','decorator','monitorSup'].includes(role)) key = 'fairies';
            else key = 'craftsmen';
            
            let candidates = state.chars.filter(c => c.type === role);
            if(candidates.length > 0) {
                let c = candidates[Math.floor(Math.random() * candidates.length)];
                fixedX = c.x + rand(-10, 10);
                fixedY = c.y - 30 + rand(-5, 5);
            } else { return; }
        }

        if (key && DIALOGUES[key]) {
            let text = DIALOGUES[key][Math.floor(Math.random() * DIALOGUES[key].length)];
            state.dialogue.active = {
                text: text,
                life: 300, 
                alpha: 0,
                targetObj: targetObj,
                x: fixedX,
                y: fixedY
            };
        } else {
            state.dialogue.timer = 100;
        }
    }
}

function drawDialogueSystem() {
    if (!state.dialogue.active) return;
    let d = state.dialogue.active;
    let x = d.x;
    let y = d.y;
    
    if (d.targetObj) {
        x = d.targetObj.x;
        y = d.targetObj.y - 25; 
    }
    drawSpeechBubble(ctx, d.text, x, y, d.alpha);
}

function loop() {
    try {
        if (state.phase === 'ENDING') {
            ctx.clearRect(0,0,canvas.width,canvas.height); drawBG();
            state.chars.forEach(c => { c.update(1); c.draw(); });
            requestAnimationFrame(loop); return;
        }
        
        let dt = state.timeScale;
        state.frame += dt; 
        state.dayTimer += dt;
        
        if (state.dayTimer > CONFIG.dayLength) { 
            if(state.isDay) { state.isDay = false; state.dayTimer = 0; state.pucks.push(new Puck()); } 
            else { finishNight(); } 
        }
        
        if(!state.isDay && state.dayTimer > CONFIG.dayLength * 0.66 && state.pucks.length < 3) {
            if(Math.floor(state.frame) % 60 === 0) { let p = new Puck(); p.x = state.pucks[0].x; p.y = state.pucks[0].y; state.pucks.push(p); createEmote(p.x, p.y, 'CLONE!'); }
        }
        if (Math.floor(state.frame) % 1200 === 0) showPuckMessage();
        updateStats();
        updateDialogueSystem(dt);

        ctx.clearRect(0,0,canvas.width,canvas.height); drawBG();
        state.houses.forEach(h=>h.draw());
        state.pedestrians.forEach(p=> { p.update(dt); p.draw(); });
        
        for (let i = state.items.length - 1; i >= 0; i--) {
            let item = state.items[i];
            item.update(dt); 
            item.draw();
            if(item.stage === 'DELETED') {
                state.items.splice(i, 1);
            }
        }

        state.chars.sort((a,b)=>a.y - b.y); 
        state.chars.forEach(c=>{c.update(dt); c.draw();}); 
        if(!state.isDay) state.pucks.forEach(p => { p.update(dt); p.draw(); });
        
        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.life -= dt;
            if (p.life <= 0) {
                state.particles.splice(i, 1);
            } else {
                if(p.type==='emote') { p.y+=p.vy * dt; ctx.fillStyle=p.c||'#fff'; ctx.font="bold 20px serif"; ctx.fillText(p.text,p.x,p.y); }
                else { p.x+=p.vx * dt; p.y+=p.vy * dt; ctx.fillStyle=p.c; ctx.globalAlpha=p.life/30; ctx.fillRect(p.x,p.y,2,2); ctx.globalAlpha=1; }
            }
        }
        
        drawDialogueSystem();
        requestAnimationFrame(loop);
    } catch (e) {
        console.error("Game Loop Error:", e);
    }
}

function startTutorial() {
    currentTutStep = 0;
    tutOverlay.classList.remove('tut-hidden');
    tutOverlay.style.display = 'flex';
    updateTutorialUI();
}

function endTutorial() {
    tutOverlay.style.display = 'none';
    tutHighlight.style.display = 'none';
}

function updateTutorialUI() {
    const step = tutorialSteps[currentTutStep];
    tutTitle.innerText = step.title;
    tutText.innerText = step.text;
    
    if (step.zone && CONFIG.zones[step.zone]) {
        const z = CONFIG.zones[step.zone];
        tutHighlight.style.display = 'block';
        tutHighlight.style.left = z.x + 'px';
        tutHighlight.style.top = z.y + 'px';
        tutHighlight.style.width = z.w + 'px';
        tutHighlight.style.height = z.h + 'px';
    } else {
        tutHighlight.style.display = 'none';
    }

    if (currentTutStep === tutorialSteps.length - 1) {
        tutNext.innerText = "Start!";
    } else {
        tutNext.innerText = "Next";
    }
}

function resetGameToDay(nextLevel) {
    state.isDay = true;
    state.dayTimer = 0;
    state.phase = 'PLAYING';
    state.level = nextLevel; // Set Level
    levelBadge.innerText = "LV." + state.level;
    
    state.pucks = [];
    state.items = []; 
    state.deliveryScores = { nightmare: 0, sweet: 0, neutral: 0 };
    state.stats = { nightmare: 0, sweet: 0, neutral: 0 };
    state.caughtNightmares = 0;
    state.rageMode = false;
    rageOverlay.style.background = "rgba(255, 0, 0, 0)";
    state.shelfSlots.fill(null);
    endingOverlay.style.display = 'none';
    state.chars.forEach(c => c.reset());
    state.dominance = 'NEUTRAL';
    
    setSpeed(1); // Reset speed to 1x on new day
}

function finishNight() {
    let s = state.stats;
    let winner = 'NEUTRAL';
    if (s.nightmare > s.sweet && s.nightmare > s.neutral) winner = 'NIGHTMARE';
    else if (s.sweet > s.nightmare && s.sweet > s.neutral) winner = 'SWEET';
    state.dominance = winner;

    state.phase = 'ENDING'; endingOverlay.style.display = 'flex';
    
    if(state.dominance === 'NIGHTMARE') { 
        endingOverlay.className = 'end-nightmare'; 
        endTitle.innerText = "SYSTEM ERROR"; 
        endDesc.innerText = "Puck corrupted the world. Resetting to Level 1."; 
        setTimeout(() => { resetGameToDay(1); }, 5000);
    } 
    else if (state.dominance === 'SWEET') {
        endingOverlay.className = 'end-sweet'; 
        endTitle.innerText = "SWEET DREAMS"; 
        endDesc.innerText = "Level Complete! Advancing to Level " + (state.level + 1); 
        setTimeout(() => { resetGameToDay(state.level + 1); }, 5000);
    }
    else {
        endingOverlay.className = 'end-neutral'; 
        endTitle.innerText = "NEUTRAL NIGHT"; 
        endDesc.innerText = "Neither side won. Try again at same level.";
        setTimeout(() => { resetGameToDay(state.level); }, 5000);
    }
}

function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    let cy = canvas.height * 0.45;
    CONFIG.zones = {
        office:{x:canvas.width/2-200,y:30,w:250,h:100}, 
        ceo:{x:canvas.width/2+80,y:30,w:100,h:80},
        raw: {x: 50, y: cy, w: 100, h: 100},
        trash: {x:60, y:cy+140, w:60, h:50},
        funnel: {x: 200, y: cy-40, w: 50, h: 60},
        belt: {x: 220, y: cy+20, w: 400, h: 40},
        beltEnd: {x: 650, y: cy+20, w: 40, h: 50},
        decoTable: {x: 700, y: cy-20, w: 100, h: 100},
        monitorQueue: {x: 800, y: cy-30, w: 30, h: 100},
        monitor: {x: 840, y: cy-80, w: 100, h: 70},
        monitorPad: {x: 840, y: cy+20, w: 100, h: 40},
        finish: {x: 980, y: cy-50, w: 140, h: 240},
    };

    state.chars = [];
    for(let role in CONFIG.roles) {
        for(let i=0; i<CONFIG.roles[role]; i++) {
            state.chars.push(CharacterFactory.create(role, i));
        }
    }
    
    state.houses = [];
    for(let i=0; i<6; i++) state.houses.push({x: 100 + i*180, y: canvas.height-80, w: 100, h: 80, win:{x:0, y:0}});
    state.houses.forEach(h => { h.win = {x: h.x+h.w/2-15, y: h.y+30, on:false, timer:0}; 
        h.draw = function() {
            ctx.fillStyle = state.isDay ? '#2c3e50' : '#1a252f'; 
            ctx.fillRect(this.x,this.y,this.w-10,this.h);
            ctx.fillStyle=CONFIG.colors.roof[0]; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x+this.w/2,this.y-20); ctx.lineTo(this.x+this.w,this.y); ctx.fill();
            
            if(this.win.timer>0) this.win.timer -= state.timeScale; else this.win.on=false;
            let winColor = state.isDay ? '#87ceeb' : (this.win.on ? this.win.color : 'rgba(0,0,0,0.3)');
            if (state.isDay) { ctx.fillStyle = winColor; ctx.fillRect(this.win.x,this.win.y,30,30); } 
            else if (this.win.on) {
                 ctx.globalAlpha = 0.6; ctx.fillStyle = winColor; ctx.fillRect(this.win.x,this.win.y,30,30);
                 ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(this.win.x,this.win.y,30,30);
                 ctx.globalAlpha = 1.0;
            }
        };
        h.receiveItem = function(item) {
             this.win.on=true; this.win.timer=300; 
             if (item.qualityType === 1) { this.win.color = CONFIG.colors.nightmare; createEmote(this.win.x+15, this.win.y-20, '!!'); }
             else if (item.qualityType === 2) { this.win.color = CONFIG.colors.sweetDream; createEmote(this.win.x+15, this.win.y-20, 'â¤ï¸'); }
             else { this.win.color = item.ingredients[0]; }
        }
    });

    state.pedestrians = Array.from({length:10}, ()=>new Pedestrian());
    state.stars = Array.from({length:50}, ()=>({x:rand(0,canvas.width), y:rand(0,canvas.height/2), size:rand(0.5,2)}));

    // Pre-spawn items for click testing
    for(let i=0; i<5; i++) {
        let item = new Item();
        item.stage = 'ON_BELT';
        item.x = CONFIG.zones.belt.x + i * 50;
        item.y = CONFIG.zones.belt.y + 15;
        state.items.push(item);
    }
    
    startTutorial();
}

// Global Event Listeners (Safe Zone)
tutNext.addEventListener('click', () => {
    currentTutStep++;
    if (currentTutStep >= tutorialSteps.length) { endTutorial(); } else { updateTutorialUI(); }
});
tutSkip.addEventListener('click', endTutorial);
helpBtn.addEventListener('click', startTutorial);

// [FIX] Mouse Interactions with DELIVERING support
canvas.addEventListener('mousedown', (e) => {
    if (tutOverlay.style.display !== 'none' || state.phase === 'ENDING') return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (!state.isDay) {
        for (let p of state.pucks) {
            if (p.stunTimer <= 0 && distSq(mx, my, p.x, p.y) < 2500) {
                p.hit(); 
                return; // í½ì„ í´ë¦­í–ˆìœ¼ë©´ ì•„ì´í…œ í´ë¦­ì€ íŒ¨ìŠ¤ (í½ ìž¡ê¸°ê°€ ìš°ì„ )
            }
        }
    }

    // 2. ì•„ì´í…œ í´ë¦­ (ê¿ˆ <-> ì•…ëª½ ë³€í™˜)
    // [MODIFIED] ê²¹ì³ì§„ ì•„ì´í…œë„ ëª¨ë‘ í´ë¦­ë˜ë„ë¡ break ì œê±°
    for (let item of state.items) {
        if (['RAW', 'FLYING_TO_FACTORY', 'ON_BELT', 'PENDING_DECO', 'PACKED', 'WAITING_MONITOR', 'MONITORING', 'AUTO_MOVE_TO_SHELF', 'ON_SHELF', 'DELIVERING'].includes(item.stage)) {
            // [MODIFIED] í´ë¦­ ë²”ìœ„ ìž¬ì¡°ì •: 1225(35px) -> 400(20px)
            // ì„¤ëª…: ê¿ˆì˜ ìµœëŒ€ ì‹œê°ì  ë°˜ê²½ì€ ì•½ 16px(ê¸°ë³¸ 10px + ì•„ìš°ë¼ 6px)ìž…ë‹ˆë‹¤.
            // ìš”ì²­í•˜ì‹  1.1ë°°(ì•½ 17.6px)ë¥¼ ê³ ë ¤í•˜ì—¬ í´ë¦­ íŽ¸ì˜ìƒ 20px(ì œê³± 400)ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.
            if (distSq(mx, my, item.x, item.y) < 400) {
                item.toggleQuality(); 
                createParticle(item.x, item.y, '#ffffff', 8); 
                // break; // ìœ ì§€ (ê²¹ì¹œ ì•„ì´í…œ ëª¨ë‘ í´ë¦­)
            }
        }
    }
});

window.addEventListener('resize',init);
init();
loop();
</script>
</body>
</html>
